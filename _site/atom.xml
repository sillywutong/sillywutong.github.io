<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-14T16:09:25+08:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Shutong Chen’s Blog</title><subtitle>CS student in junior year, Fudan University</subtitle><author><name>Shutong Chen</name></author><entry><title type="html">[cs224w笔记]4.网络聚类之谱分析方法</title><link href="http://localhost:4000/social%20network/graph-based%20machine%20learning/2020/03/14/cs224w4/" rel="alternate" type="text/html" title="[cs224w笔记]4.网络聚类之谱分析方法" /><published>2020-03-14T00:00:00+08:00</published><updated>2020-03-14T00:00:00+08:00</updated><id>http://localhost:4000/social%20network/graph-based%20machine%20learning/2020/03/14/cs224w4</id><content type="html" xml:base="http://localhost:4000/social%20network/graph-based%20machine%20learning/2020/03/14/cs224w4/">&lt;p&gt;这是斯坦福cs224w的课程笔记，根据老师讲课内容、ppt和助教的笔记和自己的理解整理的。 cs224w的资源在b站和youtube都有，不过没有字幕，jure老师的口音挺可爱的，听一俩节课也习惯了，不过有时候还是配合助教的笔记看清楚一些。&lt;/p&gt;

&lt;p&gt;助教的笔记： https://snap-stanford.github.io/cs224w-notes/network-methods/spectral-clustering&lt;/p&gt;

&lt;p&gt;课程网站（有ppt和作业）：http://web.stanford.edu/class/cs224w/&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;spectral-clustering&quot;&gt;Spectral Clustering&lt;/h1&gt;

&lt;p&gt;Here we study the important class of spectral methods for understanding networks on a global level. By “spectral” we mean the spectrum, or eigenvalues, of matrices derived from graphs, which will give us insight into the structure of the graphs themselves. In particular, we will explore spectral clustering algorithms, which take advantage of these tools for clustering nodes in graphs.&lt;/p&gt;

&lt;p&gt;The spectral clustering algorithms we will explore generally consist of three basic stages.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Preprocessing: construct a matrix representation of a graph, such as the adjacency matrix (but we will explore other options)&lt;/li&gt;
  &lt;li&gt;Decomposition: compute the eigenvectors and eigenvalues of the matrix, and use these to create a low-dimensional representation space&lt;/li&gt;
  &lt;li&gt;Grouping: assign points to clusters based on their representation in this space&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*英文内容来自助教的笔记&lt;/p&gt;

&lt;p&gt;这一节讲的是用谱分析的方法来做网络聚类。 谱分析就是研究网络邻接矩阵的特征值和特征向量， 从而获得网络结构的一些信息。 这种方法大致分为3个步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;预处理： 构建表示图结构的矩阵，例如邻接矩阵以及laplacian矩阵。&lt;/li&gt;
  &lt;li&gt;分解： 计算特征值和特征向量。用它们来表示节点。&lt;/li&gt;
  &lt;li&gt;聚类： 将节点根据它们在representation 空间中的情况聚类。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;graph-partitioning&quot;&gt;Graph Partitioning&lt;/h1&gt;

&lt;p&gt;Let’s formalize the task we would like to solve. We start out with an undirected graph G(V,E). Our goal is to partition VV into two disjoint groups A,B (so A∩B=∅ and A∪B=V) in a way that maximizes the number of connections internal to the groups and minimizes the number of connections between the two groups.&lt;/p&gt;

&lt;p&gt;To further formalize the objective, let’s introduce some terminology: 首先对问题作出定义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Cut: how much connection there is between two disjoint sets of nodes. cut(A,B)=∑i∈A,j∈Bwij where wij is the weight of the edge between nodes i and j. 即类A和类B之间的边的总和，如果是有权重的，就是总加权和。&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;cut(A, B) = \sum_{i \in A, j \in B} w_{ij}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Minimum cut:  使得两个部分之间联系最少的分割。&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;argminA,Bcut(A,B)&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we want to minimize the number of connections between A and B, we might decide to make the minimum cut our objective. However, we find that we end up with very unintuitive clusters this way – we can often simply set A to be a single node with very few outgoing connections, and B to be the rest of the network, to get a very small cut. What we need is a measure that also considers internal cluster connectivity.&lt;/p&gt;

&lt;p&gt;但是仅仅考虑两个分割之间的边数是不够的，例如有一个悬挂节点，那么它和网络其他部分的边数为1, 把它作为一个类，两个类就会非常不平衡。 所以，也要考虑到聚类的内部联系。用 conductance 来衡量聚类的好坏，conductance越小，越好。&lt;/p&gt;

&lt;p&gt;Enter the &lt;strong&gt;conductance&lt;/strong&gt;, which balances between-group and within-group connectivity concerns. We define &lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi(A, B) = \frac{cut(A, B)}{min(vol(A), vol(B))}&lt;/script&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;vol(A) = \sum_{i \in A} k_i&lt;/script&gt;

&lt;p&gt;the total (weighted) degree of the nodes in A. We can roughly think of conductance as analogous to a surface area to volume ratio: the numerator is the area of the shared surface between A and B, and the denominator measures volume while trying to ensure A and B have similar volumes. Because of this nuanced measure, picking A and B to minimize the conductance results in more balanced partitions than minimizing the cut. The challenge then becomes to efficiently find a good partition, since minimizing conductance is NP-hard.
最小化conductance是一个NP-Hard问题。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;spectral-graph-partitioning&quot;&gt;spectral graph partitioning&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先定义图的邻接矩阵A。 然后假设有一个vector x， x是所有顶点的label。 那么Ax = y ，yi的意义就是：&lt;/p&gt;

    &lt;p&gt;节点i 的所有邻居的label的总和。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;特征值和特征向量的意义？ Ax = λx，意味着，有一种特殊的节点的labeling 方式，使得 我们把一个节点i的所有邻居的label加起来，作为这个节点的新label，这个label就只是原来分配的label的λ倍， 且这个倍数是对所有的节点都一样的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Enter spectral graph partitioning, a method that will allow us to pin down the conductance using eigenvectors. We’ll start by introducing some basic techniques in spectral graph theory.&lt;/p&gt;

&lt;p&gt;The goal of spectral graph theory is to analyze the “spectrum” of matrices representing graphs. By spectrum we mean the set Λ={λ1,…,λn} of eigenvalues λiλi of a matrix representing a graph, in order of their magnitudes, along with their corresponding eigenvalues. For example, the largest eigenvector/eigenvalue pair for the adjacency matrix of a d-regular graph is the all-ones vector x=(1,1,…,1), with eigenvalue λ=d.&lt;/p&gt;

&lt;p&gt;可以证明， d-regular 的图中， d就是邻接矩阵最大的特征值。（1,1,…1)是它对应的唯一的特征向量。&lt;/p&gt;

&lt;p&gt;Exercise: what are some eigenvectors for a disconnected graph with two components, each component d-regular? Note that by the spectral theorem, the adjacency matrix (which is real and symmetric) has a complete spectrum of orthogonal eigenvectors.&lt;/p&gt;

&lt;p&gt;然后，如果是有两个连通部分，每个都是d-regular的，那么我们把一边标记为0，一边标为1， x=(0,0,..0,1,1,..1), Ax=lambdax， λ就是d。同样，也可以把一边标为1一边标为0.所以当有两个联通部分的时候， λn=λn-1. multiplicity=2（也就是λ的出现次数）。 当有k个联通部分，λn的multiplicity就是k。&lt;/p&gt;

&lt;p&gt;What kinds of matrices can we analyze using spectral graph theory?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The adjacency matrix: this matrix is a good starting point due to its direct relation to graph structure. It also has the important property of being symmetric, which means that it has a complete spectrum of real-valued, orthogonal eigenvectors.A的特征向量是正交的！！！所以，xn · xn-1=0, 如果图是d-regular连通图，那么xn=(1,1,1,…), 那么xn-1的元素和必须为0.&lt;/p&gt;

    &lt;p&gt;那么 xn-1中的元素会有一些&amp;gt;0, 有一些小于0！ 它就把点集分成了两半！&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/notes/cs224w1.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83ee35a5-c5b0-4892-b83e-3c6c7c3f72cf/Untitled.png&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Laplacian matrix ：&lt;/li&gt;
    &lt;/ol&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;L=D-A&lt;/script&gt;

    &lt;p&gt;性质：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;L 的对角线是 i的度数， 而在i，j 相连的地方，Lij=-1.&lt;/li&gt;
      &lt;li&gt;x=（1，1, …1） 那么 Lx=0.  所以， λ=λ1=0 最小的那个特征值是0.&lt;/li&gt;
      &lt;li&gt;那么，所有特征值都是非负的。&lt;/li&gt;
      &lt;li&gt;L也是实对称阵， 那么特征向量也都是正交的，并且有n个特征值。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;In particular, λ2, the second smallest eigenvalue of L, is already fascinating and studying it will let us make big strides in understanding graph clustering. By the theory of Rayleigh quotients, we have that&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\lambda_2 = \min_{x: x^T w_1 = 0} \frac{x^T L x}{x^T x}&lt;/script&gt;

    &lt;p&gt;where w1is the eigenvector corresponding to eigenvalue λ1; in other words, we minimize the objective in the subspace of vectors orthogonal to the first eigenvector in order to find the second eigenvector (remember that L is symmetric and thus has an orthogonal basis of eigenvalues).&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/notes/cs224w2.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74dbf99d-6d07-4a50-8b07-ebb0573390db/Untitled.png&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;就会变成：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/notes/cs224w3.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e1164242-182b-4e1c-baa7-82a63d218805/Untitled.png&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;这个目标的意义就是， xi - xj可以看作是节点i和节点j的label的距离，而当ijlabel 一个为正一个为负的时候，他们的距离平方就会大，如果是同一个分组的，平方和就会小。 那么这个式子就是在将节点分成两半，然后要横跨两个部分的边越少越好。（同一边的越多越好）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;how-to-find-optimal-cut-fiedler&quot;&gt;how to find optimal cut （Fiedler）&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/notes/cs224w4.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dcec1010-402a-41ea-a427-04f144d12f22/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;这个yi 只能取1或负1，是节点的label。这个目标实际上和λ2的目标很相似，只不过λ2那个式子里，xlabel是可以取任意实值的。但是，这个没办法求出精确解， 所以，有了下面的约束，并且让y可以取任意实值：因为和y的大小没有关系，所以可以约束&lt;/td&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;=1， 而&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i} y_{i}=0&lt;/script&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;就是让&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;==&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;的一个约束。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/notes/cs224w5.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea7bfa0b-b9fc-4297-a997-e545321abba9/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以， λ2 = min  f(y)&lt;/p&gt;

&lt;p&gt;而， x = arg miny f(y)  y的解就是λ2对应的特征向量。&lt;/p&gt;

&lt;p&gt;Now that we have a link between an eigenvalue of L and graph partitioning, let’s push the connection further and see if we can get rid of the hard |A|=|B| constraint – maybe there is a link between the more flexible conductance measure and λ2. Let’s rephrase conductance here in the following way: if a graph Gis partitioned into A and B where |A|≤|B| , then the conductance of the cut is defined as β=cut(A,B)/|A| . A result called the Cheeger inequality links β to λ2: in particular, &lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\beta^2}{2k_{max}} \leq \lambda_2 \leq 2\beta&lt;/script&gt;

&lt;p&gt;where kmax is the maximum node degree in the graph. The upper bound on λ2 is most useful to us for graph partitioning, since we are trying to minimize the conductance; it says that λ2 gives us a good estimate of the conductance – we never overestimate it more than by a factor of 2! The corresponding eigenvector x is defined by xi=−1/a if i∈A and xj=1/b if i∈B ; the signs of the entries of x give us the partition assignments of each node.   λ2可以作为分割的metrics &lt;strong&gt;conductance 的一个良好近似，因为λ2≤ 2β， 所以估计值比真实值大最多一倍。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;spectral-clustering-实做&quot;&gt;Spectral Clustering 实做&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;算出图的Laplacian matrix  L&lt;/li&gt;
  &lt;li&gt;计算出L 的特征值λ和特征矩阵x  ， 第二小的那个λ2 对应的特征向量x2， 对应了每个节点的label&lt;/li&gt;
  &lt;li&gt;grouping，决定x2 从哪个值分成两个partition，一般是0&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;k-个partition怎么办&quot;&gt;K 个partition怎么办&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;recursively cut into 2 partitions&lt;/li&gt;
  &lt;li&gt;cluster multiple eigenvectors， 不仅是看x2， 也看x3， x4……，一个节点就会由p个值来label， 然后可以把这些在p维空间聚类。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何选择有多少个聚类？ 如何确定k？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;eigengap： 两个相邻的特征值的绝对值差。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Most stable clustering is generally given by the value k that maximizes eigengap Δk  （这里的特征值是从大到小排序的，取从大到小扫描，两个相邻值相差最大的k）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/notes/cs224w6.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f93443c2-9203-4f99-84ba-c46dbe1366ea/Untitled.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;motif-based-spectral-clustering&quot;&gt;Motif-Based Spectral Clustering&lt;/h1&gt;

&lt;p&gt;What if we want to cluster by higher-level patterns than raw edges? We can instead cluster graph motifs into “modules”. We can do everything in an analogous way. Let’s start by proposing analogous definitions for cut, volume and conductance:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;motifs cut：cutM(S): 是一些节点在一个partition，而另一些节点在另一个partition中的motifs的数量。&lt;/li&gt;
  &lt;li&gt;volm(S): 是S中motif m的节点的数量。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;motif conductance：&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi(S) = cut_M(S) / vol_M(S)&lt;/script&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;找到optimal cut 也一样是np-hard问题&lt;/p&gt;

&lt;p&gt;算法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;preprocessing： 把原来的图转变为 一个 weighted graph，边的权重= 这条边参与motif的个数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apply spectral cluster： 根据转化后的加权图，算出它的邻接矩阵A和laplacian矩阵L。 并且求L的特征值和特征向量 λ2和x2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;grouping： 对节点按x2中的值从小到大排序， 然后分别从第i个节点处分割， 每次分割算出在第i个节点分割的motif conductance， conductance 最小的那个就是近似最好的分割。  这样比直接从0分成两半要好。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个近似也是有可证明的保障的：&lt;/p&gt;

&lt;p&gt;Again, we can prove a motif version of the Cheeger inequality to show that the motif conductance found by our algorithm is bounded above by &lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;4\sqrt{\phi_M^*}&lt;/script&gt;

&lt;p&gt;, where &lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi_M^*&lt;/script&gt;

&lt;p&gt;is the optimal conductance.&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="[&quot;social network&quot;, &quot;graph-based machine learning&quot;]" /><category term="notes" /><summary type="html">这是斯坦福cs224w的课程笔记，根据老师讲课内容、ppt和助教的笔记和自己的理解整理的。 cs224w的资源在b站和youtube都有，不过没有字幕，jure老师的口音挺可爱的，听一俩节课也习惯了，不过有时候还是配合助教的笔记看清楚一些。 助教的笔记： https://snap-stanford.github.io/cs224w-notes/network-methods/spectral-clustering 课程网站（有ppt和作业）：http://web.stanford.edu/class/cs224w/ Spectral Clustering Here we study the important class of spectral methods for understanding networks on a global level. By “spectral” we mean the spectrum, or eigenvalues, of matrices derived from graphs, which will give us insight into the structure of the graphs themselves. In particular, we will explore spectral clustering algorithms, which take advantage of these tools for clustering nodes in graphs. The spectral clustering algorithms we will explore generally consist of three basic stages. Preprocessing: construct a matrix representation of a graph, such as the adjacency matrix (but we will explore other options) Decomposition: compute the eigenvectors and eigenvalues of the matrix, and use these to create a low-dimensional representation space Grouping: assign points to clusters based on their representation in this space *英文内容来自助教的笔记 这一节讲的是用谱分析的方法来做网络聚类。 谱分析就是研究网络邻接矩阵的特征值和特征向量， 从而获得网络结构的一些信息。 这种方法大致分为3个步骤： 预处理： 构建表示图结构的矩阵，例如邻接矩阵以及laplacian矩阵。 分解： 计算特征值和特征向量。用它们来表示节点。 聚类： 将节点根据它们在representation 空间中的情况聚类。 Graph Partitioning Let’s formalize the task we would like to solve. We start out with an undirected graph G(V,E). Our goal is to partition VV into two disjoint groups A,B (so A∩B=∅ and A∪B=V) in a way that maximizes the number of connections internal to the groups and minimizes the number of connections between the two groups. To further formalize the objective, let’s introduce some terminology: 首先对问题作出定义： Cut: how much connection there is between two disjoint sets of nodes. cut(A,B)=∑i∈A,j∈Bwij where wij is the weight of the edge between nodes i and j. 即类A和类B之间的边的总和，如果是有权重的，就是总加权和。 Minimum cut:  使得两个部分之间联系最少的分割。 Since we want to minimize the number of connections between A and B, we might decide to make the minimum cut our objective. However, we find that we end up with very unintuitive clusters this way – we can often simply set A to be a single node with very few outgoing connections, and B to be the rest of the network, to get a very small cut. What we need is a measure that also considers internal cluster connectivity. 但是仅仅考虑两个分割之间的边数是不够的，例如有一个悬挂节点，那么它和网络其他部分的边数为1, 把它作为一个类，两个类就会非常不平衡。 所以，也要考虑到聚类的内部联系。用 conductance 来衡量聚类的好坏，conductance越小，越好。 Enter the conductance, which balances between-group and within-group connectivity concerns. We define  where the total (weighted) degree of the nodes in A. We can roughly think of conductance as analogous to a surface area to volume ratio: the numerator is the area of the shared surface between A and B, and the denominator measures volume while trying to ensure A and B have similar volumes. Because of this nuanced measure, picking A and B to minimize the conductance results in more balanced partitions than minimizing the cut. The challenge then becomes to efficiently find a good partition, since minimizing conductance is NP-hard. 最小化conductance是一个NP-Hard问题。 spectral graph partitioning 首先定义图的邻接矩阵A。 然后假设有一个vector x， x是所有顶点的label。 那么Ax = y ，yi的意义就是： 节点i 的所有邻居的label的总和。 特征值和特征向量的意义？ Ax = λx，意味着，有一种特殊的节点的labeling 方式，使得 我们把一个节点i的所有邻居的label加起来，作为这个节点的新label，这个label就只是原来分配的label的λ倍， 且这个倍数是对所有的节点都一样的。 Enter spectral graph partitioning, a method that will allow us to pin down the conductance using eigenvectors. We’ll start by introducing some basic techniques in spectral graph theory. The goal of spectral graph theory is to analyze the “spectrum” of matrices representing graphs. By spectrum we mean the set Λ={λ1,…,λn} of eigenvalues λiλi of a matrix representing a graph, in order of their magnitudes, along with their corresponding eigenvalues. For example, the largest eigenvector/eigenvalue pair for the adjacency matrix of a d-regular graph is the all-ones vector x=(1,1,…,1), with eigenvalue λ=d. 可以证明， d-regular 的图中， d就是邻接矩阵最大的特征值。（1,1,…1)是它对应的唯一的特征向量。 Exercise: what are some eigenvectors for a disconnected graph with two components, each component d-regular? Note that by the spectral theorem, the adjacency matrix (which is real and symmetric) has a complete spectrum of orthogonal eigenvectors. 然后，如果是有两个连通部分，每个都是d-regular的，那么我们把一边标记为0，一边标为1， x=(0,0,..0,1,1,..1), Ax=lambdax， λ就是d。同样，也可以把一边标为1一边标为0.所以当有两个联通部分的时候， λn=λn-1. multiplicity=2（也就是λ的出现次数）。 当有k个联通部分，λn的multiplicity就是k。 What kinds of matrices can we analyze using spectral graph theory? The adjacency matrix: this matrix is a good starting point due to its direct relation to graph structure. It also has the important property of being symmetric, which means that it has a complete spectrum of real-valued, orthogonal eigenvectors.A的特征向量是正交的！！！所以，xn · xn-1=0, 如果图是d-regular连通图，那么xn=(1,1,1,…), 那么xn-1的元素和必须为0. 那么 xn-1中的元素会有一些&amp;gt;0, 有一些小于0！ 它就把点集分成了两半！ Laplacian matrix ： 性质： L 的对角线是 i的度数， 而在i，j 相连的地方，Lij=-1. x=（1，1, …1） 那么 Lx=0. 所以， λ=λ1=0 最小的那个特征值是0. 那么，所有特征值都是非负的。 L也是实对称阵， 那么特征向量也都是正交的，并且有n个特征值。 In particular, λ2, the second smallest eigenvalue of L, is already fascinating and studying it will let us make big strides in understanding graph clustering. By the theory of Rayleigh quotients, we have that where w1is the eigenvector corresponding to eigenvalue λ1; in other words, we minimize the objective in the subspace of vectors orthogonal to the first eigenvector in order to find the second eigenvector (remember that L is symmetric and thus has an orthogonal basis of eigenvalues). 就会变成： 这个目标的意义就是， xi - xj可以看作是节点i和节点j的label的距离，而当ijlabel 一个为正一个为负的时候，他们的距离平方就会大，如果是同一个分组的，平方和就会小。 那么这个式子就是在将节点分成两半，然后要横跨两个部分的边越少越好。（同一边的越多越好） how to find optimal cut （Fiedler） 这个yi 只能取1或负1，是节点的label。这个目标实际上和λ2的目标很相似，只不过λ2那个式子里，xlabel是可以取任意实值的。但是，这个没办法求出精确解， 所以，有了下面的约束，并且让y可以取任意实值：因为和y的大小没有关系，所以可以约束 y =1， 而 就是让 A == B 的一个约束。 所以， λ2 = min f(y) 而， x = arg miny f(y) y的解就是λ2对应的特征向量。 Now that we have a link between an eigenvalue of L and graph partitioning, let’s push the connection further and see if we can get rid of the hard |A|=|B| constraint – maybe there is a link between the more flexible conductance measure and λ2. Let’s rephrase conductance here in the following way: if a graph Gis partitioned into A and B where |A|≤|B| , then the conductance of the cut is defined as β=cut(A,B)/|A| . A result called the Cheeger inequality links β to λ2: in particular,  where kmax is the maximum node degree in the graph. The upper bound on λ2 is most useful to us for graph partitioning, since we are trying to minimize the conductance; it says that λ2 gives us a good estimate of the conductance – we never overestimate it more than by a factor of 2! The corresponding eigenvector x is defined by xi=−1/a if i∈A and xj=1/b if i∈B ; the signs of the entries of x give us the partition assignments of each node. λ2可以作为分割的metrics conductance 的一个良好近似，因为λ2≤ 2β， 所以估计值比真实值大最多一倍。 Spectral Clustering 实做 算出图的Laplacian matrix L 计算出L 的特征值λ和特征矩阵x ， 第二小的那个λ2 对应的特征向量x2， 对应了每个节点的label grouping，决定x2 从哪个值分成两个partition，一般是0 K 个partition怎么办 recursively cut into 2 partitions cluster multiple eigenvectors， 不仅是看x2， 也看x3， x4……，一个节点就会由p个值来label， 然后可以把这些在p维空间聚类。 如何选择有多少个聚类？ 如何确定k？ eigengap： 两个相邻的特征值的绝对值差。 Most stable clustering is generally given by the value k that maximizes eigengap Δk （这里的特征值是从大到小排序的，取从大到小扫描，两个相邻值相差最大的k） Motif-Based Spectral Clustering What if we want to cluster by higher-level patterns than raw edges? We can instead cluster graph motifs into “modules”. We can do everything in an analogous way. Let’s start by proposing analogous definitions for cut, volume and conductance: motifs cut：cutM(S): 是一些节点在一个partition，而另一些节点在另一个partition中的motifs的数量。 volm(S): 是S中motif m的节点的数量。 motif conductance： 找到optimal cut 也一样是np-hard问题 算法： preprocessing： 把原来的图转变为 一个 weighted graph，边的权重= 这条边参与motif的个数。 apply spectral cluster： 根据转化后的加权图，算出它的邻接矩阵A和laplacian矩阵L。 并且求L的特征值和特征向量 λ2和x2 grouping： 对节点按x2中的值从小到大排序， 然后分别从第i个节点处分割， 每次分割算出在第i个节点分割的motif conductance， conductance 最小的那个就是近似最好的分割。 这样比直接从0分成两半要好。 这个近似也是有可证明的保障的： Again, we can prove a motif version of the Cheeger inequality to show that the motif conductance found by our algorithm is bounded above by  , where  is the optimal conductance.</summary></entry><entry><title type="html">[论文阅读笔记]Please Forget Where I Was Last Summer:The Privacy Risks of Public Location (Meta)Data 社交应用位置元数据的隐私暴露问题</title><link href="http://localhost:4000/paper%20reading/2020/03/01/privacy/" rel="alternate" type="text/html" title="[论文阅读笔记]Please Forget Where I Was Last Summer:The Privacy Risks of Public Location (Meta)Data 社交应用位置元数据的隐私暴露问题" /><published>2020-03-01T00:00:00+08:00</published><updated>2020-03-01T00:00:00+08:00</updated><id>http://localhost:4000/paper%20reading/2020/03/01/privacy</id><content type="html" xml:base="http://localhost:4000/paper%20reading/2020/03/01/privacy/">&lt;p&gt;论文题目：Please Forget Where I Was Last Summer:The Privacy Risks of Public Location (Meta)Data&lt;/p&gt;

&lt;p&gt;链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_01A-6_Drakonakis_paper.pdf&quot;&gt;Please Forget Where I Was Last Summer:The Privacy Risks of Public Location (Meta)Data&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;这篇文章研究用户在社交网站，例如推特上的位置数据，如何以及多大程度上泄露了他们的隐私（例如敏感信息，身体状况等）。他们制作了一个LPAuditor的工具，这个工具可以解释性地评价社交位置元数据（location metadata）造成的隐私泄露。&lt;/p&gt;

&lt;p&gt;这个系统首先可以以最细的粒度发现用户的关键位置（通过鉴别他们真实的邮件地址(postal addresses). 然后，他们可以自动地进行隐私信息推断， 比如发现用户去过的和健康相关的位置、宗教场所以及夜店等。&lt;/p&gt;

&lt;p&gt;作者们还进一步探索了用户活动和暴露出来的信息失配的情况。他们发现老版本的推特app，会给用户的geo-tagged的推文加上精确的GPS 坐标（在元数据里），这种做法是会侵犯用户隐私的。而当用户对自己的数据有更多选择，例如可以选择他们要发表什么粒度的location data时，这种细粒度带GPS坐标的推文94%都不会被发表，说明用户对自己精确的位置信息是十分在意的。&lt;/p&gt;

&lt;p&gt;所以，这个LPAuditor可以给用户作为一种审核工具，告诉用户在发表这个位置信息的时候，他们的什么隐私可能会被暴露，从而让用户对自己的数据有更多选择。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;（location metadata指的是用户发布的推文的位置属性（并不是用户自己打上的位置tag，而是保留在系统后台的属性数据，这种数据是对后台或者API可见的。）&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;首先讲社交网络上发布位置信息可能带来什么后果： stalking、cybercasing， cybercasing是指从用户发布的位置信息中推断出家庭住址并且推断出什么时候用户不在家，从而实施抢劫。&lt;/p&gt;

&lt;p&gt;之前的研究present了如何从用户的数据推断出用户的关键地址（家庭、工作地址等），但是却没有指出用户具体推文中的位置信息会导致的隐私泄露程度，也没有进一步探索这些推文可以进一步（自动地）推断出什么其他的敏感信息（这些研究有探索能进一步推断出的消息，但并不是用算法去自动推断，也没有实现出来）。&lt;/p&gt;

&lt;p&gt;作者present 了 LPAuditor工具。最初是一种鉴别用户家庭和工作地址（postal address的粒度）的技术，是用两级的聚类来做的，把推文进行聚类，然后把这些聚类映射到某个postal address上，这样做，对于那些用户移动带来的空间移位以及GPS错误的情况会比较鲁棒。 然后是对某个用户推文的时空特征进行分析，推断关键位置。在这个任务中， 数据集真值是手动构建的。&lt;/p&gt;

&lt;p&gt;然后他们研究那些会暴露用户在某些敏感地点的推文。这里的敏感位置指的是和三个方面有关的位置： 医疗健康、宗教、性/夜生活。 他们发现，有71%的用户在敏感地点发布过推文， 27.5%的推文可以从内容中推断出他们处于敏感位置。 当用户的推文中包含了更多的情境时，位置元信息就会泄露更多的隐私，例如用户推文中提出她在见医生而位置元信息显示在一个堕胎诊所。 不仅是推文内容，单单从分析时空特征的模型，也可以发现29.5%的用户正在敏感位置。&lt;/p&gt;

&lt;p&gt;注意到这种隐私侵犯对用户是不可见的，因为GPS坐标这种元数据只能在推特后台或者用推特API 得到，而且历史数据会一直对API可见，当用户的关键位置被成功精准发现时，这种隐私政策带来的隐私暴露会增加15倍。&lt;/p&gt;

&lt;p&gt;（这篇文章的写作真是长句好多……看起来太费劲了……）&lt;/p&gt;

&lt;h1 id=&quot;system-overview&quot;&gt;SYSTEM OVERVIEW&lt;/h1&gt;

&lt;h2 id=&quot;1-data-labeling-and-clustering&quot;&gt;1. Data labeling and Clustering&lt;/h2&gt;

&lt;h3 id=&quot;11-labeling-tweets&quot;&gt;1.1 labeling tweets：&lt;/h3&gt;

&lt;p&gt;首先要把每一条推文的GPS坐标与一个postal address对应起来。这个可以用公共的API，使用ArcGIS和Google Maps Geocoding&lt;/p&gt;

&lt;p&gt;因为数据集很大，调用API是比较不经济的。所以提出了一种caching机制，就是每当要label一个坐标时，查找附近有没有已经label好的，如果两个坐标距离小于二米，就判定他们属于两个地址。（这样会不会引入误差呀？例如在街上两个店铺有可能距离会小于两米的（聚类的时候有矫正误差））这种方法将调用次数减少到42.5%&lt;/p&gt;

&lt;p&gt;但是有一些地方API是给不出地址的。这些地方主要是大学校园、机场或者是偏远山区等。把这些label为unknown address，并不影响判断的精度。&lt;/p&gt;

&lt;h3 id=&quot;12-initial-clustering&quot;&gt;1.2 initial clustering&lt;/h3&gt;

&lt;p&gt;首先是把属于同一个postal address的推文聚到一类，计算这个聚类的中心坐标，作为该postal address的中心坐标。&lt;/p&gt;

&lt;p&gt;但是，caching机制会引入一些误差，所以作者比较了Google API返回的中心坐标和聚类得到的，如果不一样，那就采用google的作为中心坐标。但这种矫正只是对每个用户最大的那10个聚类做而已，其他的不重要。&lt;/p&gt;

&lt;p&gt;对于那些标记为unknown的，使用DBSCAN算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DBSCAN算法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;转自：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pinard/p/6208966.html&quot;&gt;DBSCAN密度聚类算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一种基于密度的聚类算法，基于密度的聚类算法一般假定类别可以通过样本分布的紧密程度决定，如果是同一类别的样本，他们之间是紧密相连的，就是说在一个类别里的样本，周围不远处一定有同类样本存在。&lt;/p&gt;

&lt;p&gt;假设我的样本集是D=(x1,x2,…,xm)则DBSCAN具体的密度描述定义如下：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1） ϵ-邻域：对于xj∈D，其ϵ-邻域包含样本集D中与xj的距离不大于ϵ的子样本集，即Nϵ(xj)={xi∈D&lt;/td&gt;
      &lt;td&gt;distance(xi,xj)≤ϵ} 这个子样本集的个数记为&lt;/td&gt;
      &lt;td&gt;Nϵ(xj)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2) 核心对象：对于任一样本xj∈Dxj∈D，如果其ϵϵ-邻域对应的Nϵ(xj)Nϵ(xj)至少包含MinPts个样本，即如果&lt;/td&gt;
      &lt;td&gt;Nϵ(xj)&lt;/td&gt;
      &lt;td&gt;≥MinPts，则xj是核心对象。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3）密度直达：如果xi位于xj的ϵ-邻域中，且xjxj是核心对象，则称xi由xj密度直达。注意反之不一定成立，即此时不能说xj由xi密度直达, 除非且xi也是核心对象。&lt;/p&gt;

&lt;p&gt;4）密度可达：对于xixi和xjxj,如果存在样本样本序列p1,p2,…,pT满足p1=xi,pT=xj 且pt+1由pt密度直达，则称xj由xi密度可达。也就是说，密度可达满足传递性。此时序列中的传递样本p1,p2,…,pT−1均为核心对象，因为只有核心对象才能使其他样本密度直达。注意密度可达也不满足对称性，这个可以由密度直达的不对称性得出。&lt;/p&gt;

&lt;p&gt;5）密度相连：对于xi和xj,如果存在核心对象样本xk，使xi和xj均由xk密度可达，则称xi和xj密度相连。注意密度相连关系是满足对称性的。&lt;/p&gt;

&lt;p&gt;DBSCAN算法是由密度可达关系导出最大密度相连的样本集合，就是一个聚类。&lt;/p&gt;

&lt;p&gt;这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的ϵ-邻域里；如果有多个核心对象，则簇里的任意一个核心对象的ϵ-邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的ϵ-邻域里所有的样本的集合组成的一个DBSCAN聚类簇。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paper/privacy1.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b01e3a99-e5ca-4d0a-9fc3-4dcc9db4f06a/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;算法过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;确定好参数ε和MinPts，初始化核心对象集合为空集，初始化聚类簇数k=0，为访问样本集等于全集，簇划分C=空集&lt;/li&gt;
  &lt;li&gt;对于每一个样本点：
    &lt;ol&gt;
      &lt;li&gt;通过规定的距离公式，找到样本点的ε-领域子样本集&lt;/li&gt;
      &lt;li&gt;如果子样本集中个数满足MinPts限制，它就是核心对象样本，加入核心对象样本集合。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果核心对象集合是空集，那算法就结束了，所有的点都是噪点或者单独一个聚类&lt;/li&gt;
  &lt;li&gt;在核心对象集合中，随机选择一个O作为初始，当前簇的核心对象队列Ωcur={o} ,初始化类别序号k=k+1， 初始化当前簇样本集合Ck={O}， 未访问样本集合更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5）如果当前簇核心对象队列Ωcur=∅，则当前聚类簇Ck生成完毕, 更新簇划分C={C1,C2,…,Ck}, 更新核心对象集合Ω=Ω−Ck， 转入步骤3。否则更新核心对象集合Ω=Ω−Ck。&lt;/p&gt;

&lt;p&gt;6）在当前簇核心对象队列Ωcur中取出一个核心对象o′,通过邻域距离阈值ϵ找出所有的ϵ-邻域子样本集Nϵ(o′)，令Δ=Nϵ(o′)∩Γ 更新当前簇样本集合Ck=Ck∪Δ, 更新未访问样本集合Γ=Γ−ΔΓ=Γ−Δ, 更新Ωcur=Ωcur∪(Δ∩Ω)−o′，转入步骤5.&lt;/p&gt;

&lt;p&gt;输出结果为： 簇划分C={C1,C2,…,Ck}&lt;/p&gt;

&lt;p&gt;简单总结就是，先找出所有核心对象，然后初始随机选择一个，它的邻域中的样本全部加入这个聚类，其中的核心样本加入队列，然后每次从队列中取出一个样本，重复上述过程，直到队列为空，这样就得到一个簇聚。 得到之后，再随机选择下一个核心对象作为另一个聚类的初始样本，再继续。&lt;/p&gt;

&lt;p&gt;在这篇文章中，作者将距离阈值设置为30米。&lt;/p&gt;

&lt;h3 id=&quot;second-level-clustering&quot;&gt;Second-level clustering&lt;/h3&gt;

&lt;p&gt;第一次聚类之后，就会发现在同一个地点范围之内，会出现不止一个聚类，通常都是一个大的聚类，然后旁边有一些非常小的，而且非常靠近的聚类。作者把这些坐标在地图上标出来，但也很难确定他们属于哪个地址，这是由多种因素造成的： 1. GPS读数不精确；2. API也有一定误差； 3. 与用户在发送推文时候的位置有关，例如用户正在离开或到达那个地方，或者在后院或隔壁。&lt;/p&gt;

&lt;p&gt;使用改进的DBSCAN方法来把这些小的聚类和大聚类合并，原则是距离不能超过50m。因为DBSCAN是会把密度相连的样本作为一类，也就是级联效应（cascading effect），改进就是在加入聚类的时候都要check这个聚类和大聚类的距离是不是50m以内。&lt;/p&gt;

&lt;p&gt;（这个2次聚类是说对第一次的DBSCAN聚出来那些unknown address 的类再聚类，还是那些精确的地址也要加进来呢？）&lt;/p&gt;

&lt;h2 id=&quot;2-identifying-key-user-locations&quot;&gt;2. Identifying Key User Locations&lt;/h2&gt;

&lt;p&gt;在鉴别哪些聚类是用户的关键位置时，&lt;strong&gt;没有用到推文中的内容和语境信息，而是单纯用时序特征，&lt;/strong&gt; 而这是基于人类社会活动的一般规则，例如8小时上班制，但对于那些上班时间很不规律的地区就不在研究范围之内了。 而之所以不用推文内容，是要强调隐私泄露的风险： 即使你很小心，在推文内容中避免了关键位置信息的透露，你的GPS坐标也会出卖你。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Home&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于两个inituitions：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在这个鉴定为home address 的聚类中，要有比较多的推文，因为用户每天都会在家一段时间。&lt;/li&gt;
  &lt;li&gt;在别的地方可能会有非常有规律的时序模式，但是在家发推文的时间就会比较分散，从很早到很晚都可能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在工作日的时候，这些特征可能会和其他地点的活动混淆，只在weekends观察会更鲁棒。&lt;/p&gt;

&lt;p&gt;他们的方法是首先找到5个周末里面推文最多的聚类，然后估计了time frame 和active hours， 选择其中time frame最长的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;work&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在工作地点发推特在时间上比较有规律。&lt;/p&gt;

&lt;p&gt;首先也是找5个推文最多的聚类，去掉已经标记为home的，然后对每个聚类， 看发推文超过一条的那些天，将第一条和最后一条之间的间隔作为time frame， 然后把这些time frame叠加起来，如果某个time frame在这个聚类超过一半的日期里都有表现，就将这个time frame作为prominent time frame。 这样可以消去一些噪音，例如用户某天加班了，也可以考虑到一些几班倒的用户。&lt;/p&gt;

&lt;p&gt;然后，将dominant time frame以外的推文删掉；并且去掉time frame经常超过10小时的聚类（这是根据US法定工作时间和欧盟一周48小时限制）。不过考虑到有些人就是会加班，所以只是把超过20%time frame大于10小时的聚类去掉。&lt;/p&gt;

&lt;p&gt;可以看到，这个算法比起传统的固定工作时间的算法要灵活许多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paper/privacy2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-identifying-highly-sensitive-places&quot;&gt;3. Identifying Highly-Sensitive Places&lt;/h3&gt;

&lt;p&gt;任务： 鉴别用户的Potentially Sensitive Clusters（PSCs），这些聚类附近有比较敏感的场所，并且确定用户是否去过这些场所。&lt;/p&gt;

&lt;p&gt;关于聚类附近是否有敏感场所，使用Foursquare‘s venue API来获取聚类附近场所的信息，附近指的是聚类中心坐标25米范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Content-based：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;聚类离敏感场所近不代表用户去过那些敏感场所，需要推文内容佐证。佐证使用的是一个手动构建的wordlist，包括医疗、宗教、sex/nightlife的关键词。&lt;/p&gt;

&lt;p&gt;首先对推文进行预处理：去掉emoji、mentions、停顿词、url，tokanization、lemmatization。&lt;/p&gt;

&lt;p&gt;然后使用tf-idf方法（term frequency - inverse document frequency）来统计关键词频率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tf-idf：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个挺简单的算法：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31197209&quot;&gt;机器学习：生动理解TF-IDF算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在这里，作者是将这个聚类的所有推文作为一个document，而将用户的所有聚类作为corpus。tf-idf会输出对于一个文档的关键词排名，所以只要检查这个聚类分数最高的前几个单词是否在wordlist中，可以决定推文context是否与sensitive venue有关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Duration-Based corroboration：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用户可能因为地点的敏感性不会在推文中发关键词，所以还用了停留时间作为依据。如果在一个聚类中，相当一段时间内用户发了多条推文，说明用户在该地点花了一段时间，就有可能访问了敏感地点。 但这种判断不confidence。&lt;/p&gt;

&lt;h3 id=&quot;4-implementation-details&quot;&gt;4. Implementation Details&lt;/h3&gt;

&lt;p&gt;这套LPAuditor工具全用Python实现，用到的数据放在Mongo db中，这一部分讲的是作者具体都用到什么工具和包，这些工具对社交分析都挺有用的，感兴趣的话可以阅读原论文。&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="Paper Reading" /><category term="privacy" /><category term="LSBN" /><summary type="html">论文题目：Please Forget Where I Was Last Summer:The Privacy Risks of Public Location (Meta)Data 链接： Please Forget Where I Was Last Summer:The Privacy Risks of Public Location (Meta)Data Abstract 这篇文章研究用户在社交网站，例如推特上的位置数据，如何以及多大程度上泄露了他们的隐私（例如敏感信息，身体状况等）。他们制作了一个LPAuditor的工具，这个工具可以解释性地评价社交位置元数据（location metadata）造成的隐私泄露。 这个系统首先可以以最细的粒度发现用户的关键位置（通过鉴别他们真实的邮件地址(postal addresses). 然后，他们可以自动地进行隐私信息推断， 比如发现用户去过的和健康相关的位置、宗教场所以及夜店等。 作者们还进一步探索了用户活动和暴露出来的信息失配的情况。他们发现老版本的推特app，会给用户的geo-tagged的推文加上精确的GPS 坐标（在元数据里），这种做法是会侵犯用户隐私的。而当用户对自己的数据有更多选择，例如可以选择他们要发表什么粒度的location data时，这种细粒度带GPS坐标的推文94%都不会被发表，说明用户对自己精确的位置信息是十分在意的。 所以，这个LPAuditor可以给用户作为一种审核工具，告诉用户在发表这个位置信息的时候，他们的什么隐私可能会被暴露，从而让用户对自己的数据有更多选择。</summary></entry><entry><title type="html">[论文阅读笔记]假新闻检测 dEFEND: Explainable Fake News Detection</title><link href="http://localhost:4000/paper%20reading/2020/02/19/defend/" rel="alternate" type="text/html" title="[论文阅读笔记]假新闻检测 dEFEND: Explainable Fake News Detection" /><published>2020-02-19T00:00:00+08:00</published><updated>2020-02-19T00:00:00+08:00</updated><id>http://localhost:4000/paper%20reading/2020/02/19/defend</id><content type="html" xml:base="http://localhost:4000/paper%20reading/2020/02/19/defend/">&lt;p&gt;论文： dEFEND: Explainable Fake News Detection&lt;/p&gt;

&lt;p&gt;KDD2019：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[KDD 2019&lt;/td&gt;
      &lt;td&gt;dEFEND: Explainable Fake News Detection](https://www.kdd.org/kdd2019/accepted-papers/view/defend-explainable-fake-news-detection)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;abstract&quot;&gt;ABSTRACT&lt;/h1&gt;

&lt;p&gt;本文研究的问题是假新闻检测，假新闻检测可以看作一个分类问题，它和谣言分类、fact check、垃圾内容挖掘等比较相似，都属于内容质量检测的领域。假新闻检测的研究方向主要有三个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据集： 假新闻标准数据集需要人工去构建。&lt;/li&gt;
  &lt;li&gt;特征方面的工作： 假新闻检测的方法可以分为基于内容和基于社交网络，这些方法都涉及到新闻文本的embedding、用户的embedding、用户之间社交网络的embedding如何获取的问题。&lt;/li&gt;
  &lt;li&gt;模型研究。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文提出，虽然之前的工作在假新闻检测上获得了比较准确的结果，但是这些模型都不是可解释的，不能告诉我们为什么判定这篇新闻是假新闻。他们提出了一个融合模型，根据新闻内容和用户评论来检测，同时能够筛选出Top-k 用户评论来解释为什么这条新闻是假的。作者在真实数据集上做实验，结果比7个模型f1-score高出5.33%，精确度大幅提升。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;这一部分主要讲了为什么假新闻检测很重要，现在新闻的传播有什么样的特点， 假新闻检测的困难在哪里，作者做出了什么样的贡献。&lt;/p&gt;

&lt;p&gt;首先随着社交网络的用户大幅增长，人们获取新闻的渠道改变，2018年已经有68%的美国成年人从社交网络上获取新闻。但社交媒体上的创作形式和传播速度让用户每天接触到大量的错误信息和虚假信息，广泛传播的假新闻会损害公众对政府、媒体的信任，改变人们对真新闻的看法，还可能对现实世界造成伤害。&lt;/p&gt;

&lt;p&gt;假新闻检测的困难在于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;因为假新闻本来就是故意写来误导读者的，它在内容上可能逻辑自洽，语气客观，仅仅基于内容很难判定它的真伪。&lt;/li&gt;
  &lt;li&gt;不能只基于内容，要结合用户评论（或者有一些模型也研究了传播特性（网络结构），以及多条新闻下多个评论用户之间的社交关系、用户的特征等）， 但社交网络数据非常庞大，有很多用户是匿名的，有很多机器人账号，这导致评论和转发中有较多的噪声。近年来比较优秀的一篇是natali他们提出来的，他们综合了新闻内容，用户评论，回复的用户的特征和关系网络来检测假新闻。也有用attention机制的，在大量的用户回复中筛选出那些重要的回复。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;作者从另一个角度提出研究课题，即在检测的同时还要解释为什么它是假新闻。这么做的好处首先是对特征研究有贡献；然后这么做有利于从噪声中分离对判断真假有用的信息，从而提高判断的准确度。&lt;/p&gt;

&lt;p&gt;什么叫做解释为什么？ 作者是从两个角度去解决的，解释可以从新闻内容中得到，也可以从用户评论中得到。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新闻内容中有一些信息是可以验证真伪的，例如涉及科学知识、人文历史等等，记者可以到一些第三方的事实鉴定网站去鉴定，但对于新的事件知识库里还没有信息，就没法检查。&lt;/li&gt;
  &lt;li&gt;用户评论含有大量信息，如立场、情感、观点，可以帮助检测&lt;/li&gt;
  &lt;li&gt;新闻内容和用户评论会有联动，用户评论可能针对新闻中某句话/某个观点提出质疑，也可以解释一条新闻为什么被判定真假。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从这两个角度去挖掘原因，作者提出的框架包括3个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编码新闻内容的模块， 具体是采用一个层级注意力网络。&lt;/li&gt;
  &lt;li&gt;编码用户评论的模块，用的是word-level注意力子网络。&lt;/li&gt;
  &lt;li&gt;sentence-comment co-attention component，用来捕捉新闻内容和用户评论之间的关系，以及选出能够解释检测结果的top-k条用户评论和新闻句子。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这篇文章强调了以下的挑战：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何同时提高检测准确度和可解释性&lt;/li&gt;
  &lt;li&gt;如何提取解释性的句子和评论，在没有真值的情况下&lt;/li&gt;
  &lt;li&gt;如何对新闻内容和用户评论之间的关系建模。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结他们的贡献，有三个方面。一是他们提出了基于社交网络的假新闻检测领域的新问题，即如何解释检测结果；二是针对这个问题提出了一个模型，三是在真实数据集上测量模型的准确性和可解释性。&lt;/p&gt;

&lt;h1 id=&quot;related-work&quot;&gt;Related work&lt;/h1&gt;

&lt;p&gt;关于假新闻检测：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/57124028&quot;&gt;一文看懂虚假新闻检测（附数据集 &amp;amp; 论文推荐）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;新闻检测分为基于新闻内容的和基于社交环境的。基于新闻内容的模型可以从文本和视觉元素提取特征。文本特征可以包括写作风格、情感等，来判断新闻写作是否中立客观；视觉特征从配图、视频中提取。&lt;/p&gt;

&lt;p&gt;基于社交环境的方法，可以包括用户、推文、社交网络三个方面的特征，用户特征是指从用户的资料来描述用户，推文是指根据用户以往的评论、推文来检测他们的立场、可信度。网络特征指的是对该新闻的传播模式、用户之间的互动关系等进行建模。&lt;/p&gt;

&lt;h2 id=&quot;可解释的机器学习&quot;&gt;可解释的机器学习&lt;/h2&gt;

&lt;p&gt;机器学习模型的可解释性也是研究的热点。可以分为两种： intrinsic 和post-hoc explainability。前者是把可解释性融合进模型结构本身，例如用权重的大小来寻找重要特征；后者是创建另外一个模型来对一个已有的模型进行解释，比如说用一个决策树，训练到能和一个神经网络产生一样的结果。&lt;/p&gt;

&lt;p&gt;这篇paper用层级注意力机制就是intrinsic的方法。&lt;/p&gt;

&lt;h1 id=&quot;问题定义&quot;&gt;问题定义&lt;/h1&gt;

&lt;p&gt;A 是一篇文章， 有N个句子si&lt;/p&gt;

&lt;p&gt;每个句子有Mi个单词，记为 w1，……wMi&lt;/p&gt;

&lt;p&gt;C={ c1……cT} 是T条评论，每条评论有w1……wQj 个单词。&lt;/p&gt;

&lt;p&gt;新闻检测问题看作是二分类问题，要学习的是分类，以及该新闻所有的T条评论的一个排序，和该新闻所有N个句子的一个排序。排序的一句是解释能力。新闻句子的解释能力指的是这个句子的信息有多check-worthy（我理解的check-worthy指的是检查有多容易以及这个句子信息的真假对&lt;/p&gt;

&lt;h1 id=&quot;模型&quot;&gt;模型&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;新闻内容编码&lt;/li&gt;
  &lt;li&gt;用户评论编码&lt;/li&gt;
  &lt;li&gt;sentence-comment co-attention&lt;/li&gt;
  &lt;li&gt;prediction&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;news-contents-encoding&quot;&gt;News contents encoding&lt;/h2&gt;

&lt;p&gt;使用的是word-sentence level的注意力机制。最近的研究喜欢用层级注意力网络来表示文本，就像上一篇新闻推荐的论文，这种网络可以根据目标的不同更好地选择特征。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;word encoder： encoder用的是双向GRU RNN。每一个单词用相应正向和反向两个单元的隐状态共同表示，包含了这个单词的上下文信息（而不是只有上文）。在这之上就是一个常规的attention 网络，权重α描述了每一个单词对该句子表示的贡献。一个句子向量vi就是单词表示的加权和。&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
&amp;\overrightarrow{\mathrm{h}_{t}^{\vec{\prime}}}=\overrightarrow{G R U}\left(\mathbf{w}_{t}^{i}\right), t \in\left\{1, \ldots, M_{i}\right\}\\
&amp;\overleftarrow{\mathrm{h}_{t}^{i}}=\overleftarrow{G R U}\left(\mathrm{w}_{t}^{i}\right), t \in\left\{M_{i}, \ldots, 1\right\}
\end{aligned} %]]&gt;&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{v}^{i}=\sum_{t=1}^{M_{i}} \alpha_{t}^{i} \mathbf{h}_{t}^{i}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sentence encoder： 也是用双向 GRU RNN。将该新闻的N个句子向量作为输入，每个句子的表示si用正向和反向的隐状态连接。&lt;/p&gt;

    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\overrightarrow{\mathrm{h}^{i}}=\overrightarrow{G R U}\left(\mathrm{v}^{i}\right), i \in\{1, \ldots, N\}&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;\overleftarrow{\mathrm{h}^{i}}=\overleftarrow{G R U}\left(\mathrm{v}^{i}\right), i \in\{N, \ldots, 1\}&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;user-comments-encoding&quot;&gt;User Comments Encoding&lt;/h2&gt;

&lt;p&gt;因为评论比较短所以就直接用word attention了。这个embedding首先是直接将每个词映射到一个embedding 矩阵的一个向量，embedding的维度是D维。然后将评论的所有单词embedding输入一个双向GRU RNN, 然后还是用相似的方法， 把隐状态加权和得到comment vector cj。&lt;/p&gt;

&lt;h2 id=&quot;sentence-comment-co-attention&quot;&gt;Sentence-Comment Co-attention&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;affinity matrix： also called similarity matrix。矩阵来衡量x和y轴数据点的相似度，常用的有余弦距离。&lt;/li&gt;
  &lt;li&gt;attention map： 是一维的attention 机制的扩展。二维的attention map是一个数值矩阵，每一个数值衡量该坐标数据点对特点目标的重要程度：attention map: a scalar matrix representing the relative importance of layer activations at different 2D spatial locations with respect to the target task。&lt;/li&gt;
  &lt;li&gt;首先构建相似度矩阵：
  &lt;script type=&quot;math/tex&quot;&gt;\mathrm{F}=\tanh \left(\mathrm{C}^{\mathrm{T}} \mathrm{W}_{l} \mathrm{S}\right)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用相似度矩阵来进一步构建二维attention 网络的权重。
  &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{aligned}
&amp;\mathrm{H}^{s}=\tanh \left(\mathrm{W}_{s} \mathrm{S}+\left(\mathrm{W}_{c} \mathrm{C}\right) \mathrm{F}\right)\\
&amp;\mathrm{H}^{c}=\tanh \left(\mathrm{W}_{c} \mathrm{C}+\left(\mathrm{W}_{s} \mathrm{S}\right) \mathrm{F}^{\mathrm{T}}\right)
\end{aligned} %]]&gt;&lt;/script&gt;
  &lt;script type=&quot;math/tex&quot;&gt;\begin{array}{l}
{\mathbf{a}^{S}=\operatorname{softmax}\left(\mathbf{w}_{h s}^{\top} \mathbf{H}^{s}\right)} \\
{\mathbf{a}^{c}=\operatorname{softmax}\left(\mathbf{w}_{h c}^{\top} \mathbf{H}^{c}\right)}
\end{array}&lt;/script&gt;&lt;/p&gt;

    &lt;p&gt;其中，as是所有N个句子的权重， ac是所有T条评论的权重。最后，句子加权和和评论加权和分别作为最终该新闻句子的表示和评论的表示。&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{\mathbf{s}}=\sum_{i=1}^{N} \mathbf{a}_{i}^{s} \mathbf{s}^{i}, \quad \hat{\mathbf{c}}=\sum_{j=1}^{T} \mathbf{a}_{j}^{c} \mathbf{c}^{j}&lt;/script&gt;

    &lt;p&gt;没看懂这个模块的数学含义，comment和sentence在事实上的相似度如何影响attention权重的？F矩阵中有w参数需要训练，但这个训练过程怎么能让F真的就代表comment和sentence之间的相似度呢？还有看起来F越接近0应该是相似度越低的，这样Hs直接=tanh（WsS）而与C无关。我们的目标函数真的能让F的参数往这个方向去优化吗？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prediction&quot;&gt;Prediction&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;预测函数：&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{\mathbf{y}}=\operatorname{softmax}\left([\hat{\mathbf{s}}, \hat{\mathbf{c}}] \mathbf{W}_{f}+\mathbf{b}_{f}\right)&lt;/script&gt;

    &lt;p&gt;这里y head是个二维向量，表示y预测为0或1的概率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目标函数：&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{L}(\theta)=-y \log \left(\hat{y}_{1}\right)-(1-y) \log \left(1-\hat{y}_{0}\right)&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模型使用RMSprop作为优化器。&lt;/p&gt;

&lt;h1 id=&quot;实验&quot;&gt;实验&lt;/h1&gt;

&lt;p&gt;实验探究3个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;defend模型能否提高假新闻检测的表现？&lt;/li&gt;
  &lt;li&gt;能提高分类表现，那么新闻内容和用户评论，分别对提高的贡献有多大？&lt;/li&gt;
  &lt;li&gt;defend能找到可以解释分类结果的句子和用户评论吗？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数据集&quot;&gt;数据集&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.politifact.com/&quot;&gt;PolitiFact&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用了一个新闻检测benchmark: FakeNewsNew. 里面的数据是从两个fact-checking平台 GossipCop和PoilitiFact获取的，PolitiFact是一个非营利性的事实鉴定平台，由用户上传statement，由调查记者调查并给出statement鉴定和调查报告。鉴定不是简单的真或者假，而是分了好几个级别。作者过滤了不足3条评论的新闻。&lt;/p&gt;

&lt;h2 id=&quot;比较方法&quot;&gt;比较方法&lt;/h2&gt;

&lt;p&gt;对比了以往七种方法，其中前两种对新闻内容的语言学特征提取和建模，还利用了心理学的知识（没具体看），HAN用层级注意力网络，但是只基于新闻内容；text-CNN用CNN去编码新闻内容。&lt;/p&gt;

&lt;p&gt;TCNN-URG用卷积网络学习新闻内容特征和用户评论特征。HPA不是基于新闻内容，反而从评论用户去获取该新闻的表示，也用了层级注意力网络。CSI则是混合方法，基于新闻内容、用户评论文本、用户特征来检测，是2017年提出之后很受关注的方法。&lt;/p&gt;

&lt;p&gt;这个实验针对问题选取了三种不同的比较组，选取的逻辑非常清晰。&lt;/p&gt;

&lt;h2 id=&quot;defend分类表现&quot;&gt;DEFEND分类表现&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用常规accuracy precision recall 和 f1来衡量。&lt;/li&gt;
  &lt;li&gt;RST\LIWC\HAN： 这三个都是只基于新闻内容的传统方法，HAN各项评分都高很多，说明层级注意力网络编码特征的能力最强； LIWC优于RST，说明语言特征对假新闻检测很有帮助。&lt;/li&gt;
  &lt;li&gt;融合用户评论的方法比单纯使用新闻内容或单纯使用评论的方法性能好。说明用户评论的确包含了新闻真伪的补充信息。&lt;/li&gt;
  &lt;li&gt;只用用户信息的方法比只用新闻内容的方法稍微好一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;量化模型中user-comment新闻内容对检测的影响&quot;&gt;量化模型中user comment/新闻内容对检测的影响&lt;/h2&gt;

&lt;p&gt;有几个defend变种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dEDEND\C： 去掉用户评论，编码新闻内容之后，直接pooling和softmax&lt;/li&gt;
  &lt;li&gt;defend、N： 不考虑新闻内容。&lt;/li&gt;
  &lt;li&gt;defend\Co: 不用co-attention，而是在新闻内容和用户评论上分别做sentence级别的self-attention。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paper/defend.png&quot; alt=&quot;results&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作者的结论是： co=attention、新闻内容、用户评论都会有贡献。然而，他们没有提到 新闻内容和用户评论在两个数据集上的作用很不一样，且po上F1比Accuracy高，Gossip上相反，这是为什么。他们也没有对这两个数据集做基本的介绍。&lt;/p&gt;

&lt;h2 id=&quot;解释性和case-study&quot;&gt;解释性和case study&lt;/h2&gt;

&lt;p&gt;对比的方法是HAN 和 HPA。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;sentence： 使用工具ClaimBuster，这个工具是一个对claim的check-worthy程度进行打分的模型，是用竞选辩论数据集去训练的，label是人们手工标注的。和HAN对比，使用MAP（mean average precisionk）。 （这里对准确对应的ground-truth，应该是把新闻输入claim buster去标注的）。 结果是defend好于HAN，好于Random&lt;/li&gt;
  &lt;li&gt;comments： comments解释性的评价就更厉害了……他们选了50篇文章（去掉不足50个词的，超过500个单词就截短），然后雇佣了AMT众包工人来评估每篇文章选出来的评论TOPK LIST。第一个任务是在DEFEND 和 HPA 得到的两个rank list（用attention 权重从大到小排列选出来的）之间进行ABtest。这个任务用三个角度来评估：&lt;/li&gt;
  &lt;li&gt;rc1和rc2投票人数比&lt;/li&gt;
  &lt;li&gt;rc1和rc2获胜的新闻条数比。&lt;/li&gt;
  &lt;li&gt;每条新闻，保证会被3个worker投票，每条新闻的比分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结果是rc1票数远比rc2多，在新闻比分上，3：0和2：1加起来大于60%。&lt;/p&gt;

&lt;p&gt;第二个任务，是让工人对list里面的每一条评论进行0-4解释性打分。评价标准是NDCG和Precision，这里Precision指的是在rank list里面的条目是相关条目的比例。&lt;/p&gt;

&lt;h2 id=&quot;case-study&quot;&gt;Case Study&lt;/h2&gt;

&lt;p&gt;里面确实highlight了非常有价值的用户评论，且和文本有很强对应；有用的评论也比无关信息、有太强主观性的评论得分高。&lt;/p&gt;

&lt;h1 id=&quot;future-work&quot;&gt;Future work&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;结合fact-checking 网站上列出来的调查结论，可能可以更好地highlight新闻句子和用户评论&lt;/li&gt;
  &lt;li&gt;结合更多的用户信息，例如评论获得点赞数，也可能更好帮助筛选重要评论&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Shutong Chen</name></author><category term="Paper Reading" /><category term="news" /><category term="attention" /><summary type="html">论文： dEFEND: Explainable Fake News Detection KDD2019： [KDD 2019 dEFEND: Explainable Fake News Detection](https://www.kdd.org/kdd2019/accepted-papers/view/defend-explainable-fake-news-detection) ABSTRACT 本文研究的问题是假新闻检测，假新闻检测可以看作一个分类问题，它和谣言分类、fact check、垃圾内容挖掘等比较相似，都属于内容质量检测的领域。假新闻检测的研究方向主要有三个： 数据集： 假新闻标准数据集需要人工去构建。 特征方面的工作： 假新闻检测的方法可以分为基于内容和基于社交网络，这些方法都涉及到新闻文本的embedding、用户的embedding、用户之间社交网络的embedding如何获取的问题。 模型研究。 本文提出，虽然之前的工作在假新闻检测上获得了比较准确的结果，但是这些模型都不是可解释的，不能告诉我们为什么判定这篇新闻是假新闻。他们提出了一个融合模型，根据新闻内容和用户评论来检测，同时能够筛选出Top-k 用户评论来解释为什么这条新闻是假的。作者在真实数据集上做实验，结果比7个模型f1-score高出5.33%，精确度大幅提升。</summary></entry><entry><title type="html">MIT 6.828 JOS操作系统实验6-文件系统实现详解</title><link href="http://localhost:4000/lab%20report/2020/02/03/OS6filesystem/" rel="alternate" type="text/html" title="MIT 6.828 JOS操作系统实验6-文件系统实现详解" /><published>2020-02-03T00:00:00+08:00</published><updated>2020-02-03T00:00:00+08:00</updated><id>http://localhost:4000/lab%20report/2020/02/03/OS6filesystem</id><content type="html" xml:base="http://localhost:4000/lab%20report/2020/02/03/OS6filesystem/">&lt;h1 id=&quot;lab6文件系统实现&quot;&gt;Lab6：文件系统实现&lt;/h1&gt;

&lt;p&gt;JOS操作系统提供了一个简单的文件系统，它可以满足基本功能：创建，读取，写入，删除和以分层目录结构来组织文件。但并未提供文件所有权、用户权限的概念，不支持硬链接、符号链接、时间戳或特殊设备文件等，它提供的保护仅能捕获错误。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;磁盘上的文件系统结构&quot;&gt;磁盘上的文件系统结构&lt;/h2&gt;

&lt;p&gt;文件储存在磁盘上，磁盘最小的存储单位为扇区，JOS采用的扇区大小为512字节。为了提高数据交换的效率，与磁盘的一次数据交换以块为单位，不同的操作系统定义不同的块大小，具体而言，更大地块管理的开销越小，但是可能出现的内部碎片越多。JOS采用的块大小为4096bytes，与内存的页大小相同。块和扇区的大小定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inc/fs.h&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs/fs.h&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define BLKSIZE		PGSIZE
#define BLKBITSIZE	(BLKSIZE * 8)
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define SECTSIZE	512			// bytes per disk sector
#define BLKSECTS	(BLKSIZE / SECTSIZE)	// sectors per block
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大多数UNIX文件系统采用索引结构来组织文件的块，为每一个文件分配一个&lt;strong&gt;索引节点（inode）&lt;/strong&gt;，索引节点上保存了文件的重要元数据，包括文件名称，大小，创建者，创建日期，权限，以及文件的数据块存放的物理位置。&lt;strong&gt;inode号码&lt;/strong&gt;而非文件名唯一地标识了系统中的一个文件。&lt;/p&gt;

&lt;p&gt;一般情况下，文件全名与inode号码是意义对应的关系，但UNIX系统允许硬链接，也就是多个文件名指向同一个inode，可以用不同的文件名访问同一个文件，不同的文件名没有依赖关系。当删除一个文件名时，不会影响到其他文件名对该inode的访问，只有在链接数为0的时候，该inode才会被真正释放。由于JOS不实现硬链接或者符号链接，因此目录之间是没办法共享文件的，所以不需要采用inode结构，直接将文件的元数据存放在目录条目中。&lt;/p&gt;

&lt;h3 id=&quot;超级块&quot;&gt;超级块&lt;/h3&gt;

&lt;p&gt;在一个UNIX系统中，一般会存在许多种文件系统，例如ext4，NFS, tmpfs等等，他们有着自己的组织方法，权限设置，文件数据块大小定义等，因此文件的创建、打开、删除等具体操作都是不同的。为了让用户透明地处理文件，操作系统引入了虚拟文件系统，封装不同文件系统的文件操作，为用户提供统一的文件操作接口。用户访问文件系统的过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/27/16af9c99190c78db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;How userspace accesses various types of filesystems&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样，不同的文件系统必须提供描述该系统的元数据，例如块大小，总磁盘大小，根目录，块设备驱动程序描述符指针，上次安装文件系统的时间，上次检查文件系统错误的时间等等，这些元数据存放在&lt;strong&gt;超级块&lt;/strong&gt; 中。超级块存放在磁盘的最开始或者结尾，并且为了可靠性会在不同区域中备份。&lt;/p&gt;

&lt;p&gt;JOS的超级块数据结构定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inc\fs.h&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Super&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_magic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Magic number: FS_MAGIC&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_nblocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Total number of blocks on disk&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Root directory node&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;包括文件系统魔术字、总共有多少块和根目录节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pdos.csail.mit.edu/6.828/2018/labs/lab5/disk.png&quot; alt=&quot;磁盘布局&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;文件元数据&quot;&gt;文件元数据&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct File&lt;/code&gt;描述了文件的元数据：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXNAMELEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// filename&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// file size in bytes&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// file type&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Block pointers.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// A block is allocated iff its value is != 0.&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_direct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NDIRECT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// direct blocks&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_indirect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// indirect block&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Pad out to 256 bytes; must do arithmetic in case we're compiling&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// fsformat on a 64-bit machine.&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_pad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXNAMELEN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NDIRECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// required only on some 64-bit machines&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;f_name: 文件名，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAXNAMELEN&lt;/code&gt;定义为128字节。&lt;/li&gt;
  &lt;li&gt;f_size: 以字节为单位的文件大小&lt;/li&gt;
  &lt;li&gt;f_type： 文件类型（用来区分是普通文件还是目录）&lt;/li&gt;
  &lt;li&gt;f_direct:  直接索引块，NDIRECT被定义为10。&lt;/li&gt;
  &lt;li&gt;f_indirect: 间接索引块，只有1块。&lt;/li&gt;
  &lt;li&gt;f_pad:  这是元数据结构的padding，填充使得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;结构的大小为256字节。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;元数据存储在磁盘上的目录条目中。文件数据块使用索引来组织，每一条索引存放着对应文件数据块的物理地址（块号）。直接索引块有10个，意味着大小不超过10 *4096=40KB的文件可以直接映射。间接索引块只有一个，可以存放4096/4 = 1024个额外的直接索引块，因此可以提供1024*4096 =4MB的空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文件系统允许的文件大小为4MB+40KB，1034块&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pdos.csail.mit.edu/6.828/2018/labs/lab5/file.png&quot; alt=&quot;档案结构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;目录文件&quot;&gt;目录文件&lt;/h3&gt;

&lt;p&gt;目录实际上也是一个文件，只是其中存放的是每个文件的元数据（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;结构体），描述其中的文件和子目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根目录的元数据保存在超级块中&lt;/strong&gt;。根目录文件存放了一系列子目录和文件的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;元数据，虚拟文件系统可以根据超级块找到根目录的元数据，从而访问到根目录文件的每一块，进而再通过元数据找到具体文件。&lt;/p&gt;

&lt;h3 id=&quot;磁盘空间管理&quot;&gt;磁盘空间管理&lt;/h3&gt;

&lt;p&gt;如上面的结构图所示，JOS用bitmap来管理磁盘的空闲块。在创建文件或文件内容需要扩展时，JOS根据bitmap找到空闲的磁盘块并分配给它；当文件空间释放时，文件系统将bitmap中对应的块置为1，表示该块已经空闲。Bitmap的管理相对于空闲块链表来说更加高效，但是也会占据较大空间。因为文件系统最多只能管理3GB的磁盘，则最多有786，432块，需要98，304字节的bitmap，即24个bitmap块。&lt;/p&gt;

&lt;h3 id=&quot;访问磁盘&quot;&gt;访问磁盘&lt;/h3&gt;

&lt;p&gt;文件系统的实现需要访问磁盘。一般的UNIX系统中，因为有许多异质的IO设备，因此要将磁盘驱动程序安装为内核的一部分，并提供系统调用使得文件系统可以访问磁盘。在JOS中，为了方便，直接将磁盘驱动程序实现在文件系统的用户级环境中，使得文件系统可以直接访问磁盘。&lt;/p&gt;

&lt;p&gt;JOS中程序与磁盘数据交换的方式是轮询， 即基于编程IO的磁盘访问。&lt;/p&gt;

&lt;p&gt;本次实验中，我们要实现与探究的问题有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件系统中，文件逻辑块是如何映射到物理块上的&lt;/li&gt;
  &lt;li&gt;文件创建或扩展时，如何分配磁盘块&lt;/li&gt;
  &lt;li&gt;需要访问文件时，如何将文件数据从磁盘上读取到内存缓冲区中&lt;/li&gt;
  &lt;li&gt;如何把内存中的文件数据写回到磁盘&lt;/li&gt;
  &lt;li&gt;如何为用户提供读、写、创建、删除的接口&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;todo1&quot;&gt;TODO1:&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;i386_init通过将ENV_TYPE_FS类型传递给环境创建函数env_create来标识文件系统环境。在env.c中修改env_create，使其授予文件系统环境I/O权限，但不要将该权限授予其他环境。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JOS中，环境实际上与用户进程类似， 一个环境包括环境的状态（RUNNING \RUNNABLE等），环境的地址空间，环境的父级id，中断帧等，与进程相似。可以通过系统调用fork来创建用户环境，当发生中断时，保存用户环境的运行状态到中断帧中，然后进入内核处理中断。环境描述还包括环境的类型，只有两种——ENV_TYPE_USER和ENV_TYPE_FS，前者为普通的用户进程，后者为文件系统环境。&lt;/p&gt;

&lt;p&gt;系统开启时，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init.c&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i386_init()&lt;/code&gt;中会创建文件系统进程：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;boot_aps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//将初始化代码拷贝到MPENTRY_PADDR处，然后依次启动所有AP&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Start fs.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ENV_CREATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fs_fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENV_TYPE_FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I / O指令，例如IN和OUT指令。JOS的磁盘寄存器位于x86的IO空间中，因此我们需要赋予文件系统环境IO权限，但不允许其他任何环境，包括内核访问磁盘。&lt;/p&gt;

&lt;p&gt;一个进程只能使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POPF&lt;/code&gt;指令来更改IOPL，但是这条指令的执行也需要内核级特权，文件系统环境并不具有内核级特权。所以，需要在运行于内核模式的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_create&lt;/code&gt;中，判断环境类型是否为文件系统，然后手动修改该环境下的EFLAGS寄存器。代码为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;env_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnvType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// LAB 3: Your code here.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;create env failed&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENV_TYPE_FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf_eflags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FL_IOPL_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;load_icode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，FL_IOPL_MASK在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中定义。eflags寄存器中的第12和13位为IO特权级别位（IOPL），从0-3分别对应4种模式：内核、驱动程序、驱动程序、应用程序。当前的进程只有当权限位&amp;lt;=IOPL时，才可以获得访问IO的权限， 否则就会引发保护异常。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e-&amp;gt;env_tf.tf_flags|=FL_IOPL_MASK&lt;/code&gt;将EFLAGS寄存器置为0x3000，即IOPL=3，也就是该进程的用户模式可访问IO, 于是文件系统便获得IO权限，而对于其他用户环境，eflags中的IOPL位仍为0. &lt;strong&gt;因为每一个进程都有自己独立的标志寄存器，所以用户环境与文件系统环境具有不同的IOPL。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Env 数据结构为环境描述符，类似于PCB，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inc\env.h&lt;/code&gt;中定义：&lt;/p&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trapframe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Saved registers&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Next free Env&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Unique environment identifier&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_parent_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// env_id of this env's parent&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnvType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Indicates special system environments&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Status of the environment&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_runs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Number of times environment has run&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_cpunum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// The CPU that the env is running on&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Address space&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Kernel virtual address of page dir&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Exception handling&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_pgfault_upcall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Page fault upcall entry point&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Lab 4 IPC&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_ipc_recving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Env is blocked receiving&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_ipc_dstva&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// VA at which to map received page&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_ipc_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Data value sent to us&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_ipc_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// envid of the sender&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_ipc_perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Perm of page mapping received&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_tf&lt;/code&gt;为中断帧，中断帧数据结构&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trapframe&lt;/code&gt;与之前的实验类似，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tf_eflags&lt;/code&gt;为进程的EFLAGS寄存器。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;###问题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在环境切换的时候是否需要其他操作来确保IOPL正确设置和还原？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不需要。因为在环境切换的时候，操作系统会保存旧的中断帧在内核栈上，其中就包括了EFLAGS寄存器。在环境切换回来的时候，会从内核栈上加载中断帧，恢复原来的EFLAGS寄存器值。&lt;/p&gt;

&lt;h3 id=&quot;检查&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./grade-lab5&lt;/code&gt;进行检查：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;C:\Users\CST\AppData\Roaming\Typora\typora-user-images\image-20191212212137127.png&quot; alt=&quot;image-20191212212137127&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs i/o&lt;/code&gt;结果为OK, 说明文件系统已有IO权限。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;todo2&quot;&gt;TODO2:&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;​    在fs / bc.c中实现bc_pgfault和flush_block函数。 bc_pgfault是一个页面错误处理程序，bc_pgfault的工作是从磁盘加载页面，flush_block函数应将一个块写出到磁盘。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了解决磁盘与CPU处理数据速度的不同与数据大小的不同，通常要在两者之间加入缓冲区。缓冲区实际上是内存上的一块特定区域。JOS的缓冲区只有一个块， 代码在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs\bc.c&lt;/code&gt;中。&lt;/p&gt;

&lt;h3 id=&quot;bc_pgfault&quot;&gt;bc_pgfault()&lt;/h3&gt;

&lt;p&gt;文件系统在JOS中本质上是一个进程，它如何提供其他进程访问文件的接口呢？&lt;/p&gt;

&lt;p&gt;内核将磁盘的物理地址映射到文件系统进程的高虚拟地址空间。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.h&lt;/code&gt;中，磁盘映射的虚拟地址和磁盘大小的定义是：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* Disk block n, when in memory, is mapped into the file system
 * server's address space at DISKMAP + (n*BLKSIZE). */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define DISKMAP		0x10000000
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Maximum disk size we can handle (3GB) */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define DISKSIZE	0xC0000000
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;意味着该文件系统只能处理最多3GB的磁盘。磁盘地址被映射到文件系统进程的高地址3GB区域，从0x10000000开始。这样，磁盘地址映射到文件系统虚拟地址，而虚拟地址又在被访问时映射到内存的物理地址，当其他进程向文件系统请求读取文件时，文件系统访问虚拟地址空间来读取相应的块。&lt;/p&gt;

&lt;p&gt;对于文件系统，磁盘块的读取和普通进程访问代码和数据时按需调页的策略类似，是按需加载的。只有当某个磁盘块被需要时，才要将其加载进内存。当文件系统进程访问某个虚拟地址时，如果对应的磁盘块还不在内存中，就会发生缺页故障，这时应该将虚拟地址对应的磁盘块读入内存，这与普通用户的页错误处理不同，需要自定义页错误处理程序。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bc_pgfault&lt;/code&gt;函数将磁盘块读取到对应的内存，才可以重新执行该访问。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;正常情况下，用户环境运行在JOS分配给用户的正常栈上。但当用户模式下发生页错误时，JOS内核将从正常用户栈切换到用户异常栈，来运行用户级页面错误处理程序。在异常栈上，有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTrapframe&lt;/code&gt;结构体，为&lt;strong&gt;异常中断帧&lt;/strong&gt;，它保存了引起页错误的虚拟地址。&lt;/p&gt;

  &lt;p&gt;处理用户态页面异常的过程是：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;发生异常之前，用户已经向内核注册自定义的页面处理程序在env_pgfault_upcall中。&lt;/li&gt;
    &lt;li&gt;用户态发生页错误，陷入内核态，保存正常的中断帧Trapframe，切换到内核栈，进入trap（）&lt;/li&gt;
    &lt;li&gt;根据中断号发现是缺页故障，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_fault_handler&lt;/code&gt;进行处理&lt;/li&gt;
    &lt;li&gt;检测trapframe上保存的cs寄存器，发现是用户态&lt;/li&gt;
    &lt;li&gt;判断是否有用户自定义页面异常处理程序，若没有则销毁进程。&lt;/li&gt;
    &lt;li&gt;如果有，压入Utrapframe，并设置tf-&amp;gt;tf_eip即下一条指令为用户自定义的缺页处理程序，返回用户态&lt;/li&gt;
    &lt;li&gt;用户态会从自定义处理程序开始执行。&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;&lt;strong&gt;文件系统进程自定义了它的缺页处理程序为bc_pgfault&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bc_pgfault&lt;/code&gt;首先对访问的虚拟地址进行了合法性检查：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;bc_pgfault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UTrapframe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf_fault_va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Check that the fault was within the block cache region&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		      &lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf_eip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Sanity check the block number.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_nblocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;reading non-existent block %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虚拟地址必须在磁盘映射的虚拟地址范围之内，并且由于文件系统所占有的磁盘空间可能比3GB要小，所以要检查对应的磁盘块号是否在文件系统的范围内（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockno &amp;lt; super-&amp;gt;s_nblocks&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;接下来，由于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr&lt;/code&gt;不一定与页大小对齐，所以要先将它与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGSIZE&lt;/code&gt;对齐：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDDOWN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后将磁盘块读入内存，则首先要在内存中分配一个页。JOS的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall.c&lt;/code&gt;中实现了分配内存页的系统调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_page_alloc&lt;/code&gt;, 它的接口是：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sys_page_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它为id为envid的环境在内存中分配一个页，并将页首地址映射到虚拟地址va, 设置这个页的权限为perm。（与上次实验一样，PTE_U表示用户可读，PTE_W表示可写，PTE_P表示存在内存中）。&lt;/p&gt;

&lt;p&gt;我们知道&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init.c&lt;/code&gt;中，文件系统环境是第一个被create出来的进程：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;c1&quot;&gt;// Starting non-boot CPUs&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;boot_aps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//将初始化代码拷贝到MPENTRY_PADDR处，然后依次启动所有AP&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Start fs.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ENV_CREATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fs_fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENV_TYPE_FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#if defined(TEST)
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Don't touch -- used by grading script!&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ENV_CREATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENV_TYPE_USER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的envid为0.&lt;/p&gt;

&lt;p&gt;所以可以用：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sys_page_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;来分配页。文件系统对这个页的权限当然是可读可写。&lt;/p&gt;

&lt;p&gt;如果内存大小不够的话，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_page_alloc&lt;/code&gt;会返回E_NO_MEM错误，否则返回0. 这里加以判断，如果内存不足抛出panic。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ide.c&lt;/code&gt;磁盘驱动程序提供了读取磁盘的接口：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ide_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nsecs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nsecs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;ide_wait_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nsecs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xE0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diskno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// CMD 0x20 means read sector&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nsecs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nsecs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SECTSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ide_wait_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;insl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1F0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SECTSIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;磁盘驱动器中读取磁盘的单位是一个扇区。提供的接口中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secno&lt;/code&gt;表示开始扇区号，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dst&lt;/code&gt;表示数据输出的地址，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nsecs&lt;/code&gt;表示读取扇区数目。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLKSECTS&lt;/code&gt;定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.h&lt;/code&gt;中，为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLKSIZE/SECSIZE&lt;/code&gt;,表示一个块包含的扇区数，则这里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secno&lt;/code&gt;应该为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockno * BLKSECTS&lt;/code&gt;, 目的地址为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr&lt;/code&gt;， 读取扇区数为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLKSECTS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bc_pgfault()&lt;/code&gt;的实现：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;bc_pgfault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UTrapframe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf_fault_va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Check that the fault was within the block cache region&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		      &lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf_eip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Sanity check the block number.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_nblocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;reading non-existent block %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Allocate a page in the disk map region, read the contents&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// of the block from the disk into that page.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Hint: first round addr to page boundary. fs/ide.c has code to read&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// the disk.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// LAB 5: you code here:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDDOWN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys_page_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;failed to alloc page: %e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ide_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BLKSECTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSECTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        	&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;in bc_pgfault,ide_read: %e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


	&lt;span class=&quot;c1&quot;&gt;// Clear the dirty bit for the disk block page since we just read the&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// block from disk&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_page_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uvpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGNUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_SYSCALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;in bc_pgfault, sys_page_map: %e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Check that the block we read was allocated. (exercise for&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// the reader: why do we do this *after* reading the block&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// in?)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitmap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_is_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;reading free block %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;flush_block&quot;&gt;flush_block&lt;/h3&gt;

&lt;p&gt;flush_block函数必要时将内存中的一个磁盘块的数据写回磁盘, 然后将该块的脏位置为0. 这里的必要，指的是当该块在内存中并且脏位为1的时候。假如数据没有发生改变，那么就没必要写磁盘。形参&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr&lt;/code&gt;是文件系统进程中的一个虚拟地址，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockno=((uint32_t)addr - DISKMAP) / BLKSIZE;&lt;/code&gt;将它转为磁盘块号。同样，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr&lt;/code&gt;需要对齐到页大小。&lt;/p&gt;

&lt;p&gt;根据提示，首先用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va_is_mapped&lt;/code&gt;判断该虚拟地址是否绑定到内存物理地址上，如果没有，说明该块不在内存中，不需要写回。用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va_is_dirty&lt;/code&gt;判断该虚拟地址对应页是否被修改过，如果没有也直接返回。&lt;/p&gt;

&lt;p&gt;否则用磁盘驱动器的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ide_write(uint32_t secno, const void *src, size_t nsecs)&lt;/code&gt;接口来写回块。同样以扇区为单位操作，src是数据块的源虚拟地址。&lt;/p&gt;

&lt;p&gt;写回之后，把内存上该块的脏位（PTE_D）置为0. 可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_page_map&lt;/code&gt;来实现。sys_page_map的接口是：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sys_page_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcenvid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;srcva&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	     &lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dstenvid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dstva&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它将进程 srcenvid的虚拟地址srcva映射到进程dstenvid的dstva处，并将权限设置为perm。&lt;/p&gt;

&lt;p&gt;可以通过将源和目的虚拟地址都设置为文件系统的虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr&lt;/code&gt;, 并将perm设置为 uvpt[PGNUM(addr)]&amp;amp; PTE_SYSCALL来把PTE_D清空, 并保留addr页面原来的权限设置。&lt;/p&gt;

&lt;p&gt;PTE_SYSCALL是只有用户程序进行系统调用时才会设置的，它的值是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)&lt;/code&gt;, PTE_AVAIL表示可为用户使用。&lt;/p&gt;

&lt;p&gt;加上错误处理，flush_block()实现便完成：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Flush the contents of the block containing VA out to disk if&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// necessary, then clear the PTE_D bit using sys_page_map.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// If the block is not in the block cache or is not dirty, does&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// nothing.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hint: Use va_is_mapped, va_is_dirty, and ide_write.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hint: Don't forget to round addr down.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;flush_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISKMAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flush_block of bad va %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here.&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDDOWN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va_is_mapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va_is_dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ide_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSECTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSECTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;in flush_block, ide_write(): %e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_page_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uvpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGNUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_SYSCALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;in flush_block, sys_page_map: %e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查-1&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make grade&lt;/code&gt;后：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check_bc&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check_super&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check_bitmap&lt;/code&gt;OK，表示两个函数实现正确。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;todo3&quot;&gt;TODO3:&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用free_block作为模板在fs / fs.c中实现alloc_block，后者应在bitmap中找到可用的磁盘块，将其标记为已使用，然后返回该块的编号。 分配该块时，应立即使用flush_block将更改后的bitmap块刷新到磁盘，以帮助文件系统保持一致。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;alloc_block的过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从第一个块号开始，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block_is_free&lt;/code&gt;判断它是否空闲，找到第一个空闲的块。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block_is_free&lt;/code&gt;就是从判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitmap&lt;/code&gt;中该块对应的bit是否为1（free），如果是则返回真。&lt;/li&gt;
  &lt;li&gt;找到第一个空闲块后，将bitmap中对应的位置为0.&lt;/li&gt;
  &lt;li&gt;使用flush_block()将该块对应的bitmap块写回磁盘，保持同步。因为flush_block()接收的是虚拟地址，所以还要使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diskaddr&lt;/code&gt;将块号转化为虚拟地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitmap&lt;/code&gt;数据结构在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.h&lt;/code&gt;中定义，是一个类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt;的数组，那么数组的一个元素（32位）就可以表示32个块。要判断一个块是否空闲，应该用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitmap[blockno/32] &amp;amp;= 1&amp;lt;&amp;lt;blockno%32&lt;/code&gt;是否为1来判断。则要将某一位置为0，可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitmap[blockno/32] &amp;amp;= ~(1&amp;lt;&amp;lt;blockno%32)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在JOS中，磁盘的第一个块（blockno=0）是boot sector，第二个块（blockno=1）是超级块，第三个块（blockno=2）开始才是bitmap块。因此给定一个块号blockno，它的bitmap所在的块为： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2+ (blockno/32) / (BLKSIZE /4 )&lt;/code&gt;.  一个bitmap元素的大小是4个字节，一个块大小是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLKSIZE&lt;/code&gt;，所以一个块总共有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLKSIZE/4&lt;/code&gt;个bitmap元素， blockno/32为该块对应的bitmap索引号，除以每块能存放的元素数就是相对的块偏移。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diskaddr&lt;/code&gt;定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bc.c&lt;/code&gt;中，它接收一个磁盘块号，返回在文件系统进程中对应的虚拟地址。&lt;/p&gt;

&lt;p&gt;alloc_block的实现如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;alloc_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// The bitmap consists of one or more blocks.  A single bitmap block&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// contains the in-use bits for BLKBITSIZE blocks.  There are&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// super-&amp;gt;s_nblocks blocks in the disk altogether.&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_nblocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_is_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;bitmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将bitmap上对应的位置为0，表示占用。&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;flush_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diskaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BLKSIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//bitmap的第一块磁盘块号是2, blockno/32是该blockno在bitmap中的索引号。&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_NO_DISK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查-2&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make grade&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc_block&lt;/code&gt;OK, 代码正确。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;todo4&quot;&gt;TODO4&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;实现file_block_walk和file_get_block。 file_block_walk从文件中的块偏移量映射到struct File或间接块中的指针，非常类似于pgdir_walk对页表所做的操作。 file_get_block更进一步，并映射到实际的磁盘块，并在必要时分配一个新的磁盘块。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;阅读fs-c中的代码&quot;&gt;阅读fs. c中的代码&lt;/h3&gt;

&lt;p&gt;fs.c中实现了文件系统的各种操作，包括初始化、从根目录开始遍历文件系统以找到某个绝对路径标识的文件、在目录上分配一个文件的条目、获取一个文件的条目、获取文件的某个块等基本操作，以及对文件进行创建、打开、删除、修改、读取、写回磁盘、扩展、截短等操作。&lt;/p&gt;

&lt;p&gt;JOS中，有两个磁盘映像。如果磁盘1可用的话，磁盘0只用来装载内核，磁盘1上才实现了文件系统。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_init()&lt;/code&gt;函数检查可用磁盘，并设置超级块&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super&lt;/code&gt;为该磁盘的第二块。&lt;/p&gt;

&lt;p&gt;fs.c中所有的函数以及对应的功能为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bitmap操作：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block_is_free(blockno)&lt;/code&gt;: 接收磁盘块号，根据bitmap判断块是否空闲&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free_block(blockno)&lt;/code&gt;: 接收磁盘块号，释放该块，将bitmap中对应位置1.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc_block()&lt;/code&gt;: 根据bitmap找到第一个空闲块，将它分配出去，返回块号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件系统结构构建和维护：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_init()&lt;/code&gt;： 初始化文件系统。找到可用磁盘，设置磁盘驱动，读取超级块并保存指针到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)&lt;/code&gt;: 查找文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;个块的磁盘地址（通过该文件元数据中的索引来查找），将该索引的地址存放到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ppdiskbno&lt;/code&gt;中；由于直接索引只有10个，则当块号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fileno&lt;/code&gt;大于9时，而间接索引还没有分配的时候，如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;，就分配一个间接索引页，然后将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ppdiskbno&lt;/code&gt;置为该间接索引页上对应的索引地址。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_get_block(struct File *f, uint32_t filebno, char **blk) &lt;/code&gt;: 查找文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;块在文件系统进程中对应的虚拟地址，并将其保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blk&lt;/code&gt;中&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; dir_lookup(struct File *dir, const char *name, struct File **file) &lt;/code&gt;: 在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DIR&lt;/code&gt;指定的目录下寻找名字为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;的文件的元数据，并将元数据的地址保存到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt;中。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; dir_alloc_file(struct File *dir, struct File **file) &lt;/code&gt;: 在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dir&lt;/code&gt;目录下寻找一个没有被使用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;结构，把它分配给一个新文件使用（调用者负责填充这块元数据），将它的地址存放到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt;中。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem) &lt;/code&gt;: 解析&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;中的文件路径，如果成功，将文件的元数据地址存放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pf&lt;/code&gt;中，将文件所在目录的元数据地址存放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pdir&lt;/code&gt;中。如果不成功，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pdir&lt;/code&gt;还是存放最后匹配的目录元数据地址，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastelem&lt;/code&gt;存放最后无法匹配的路径字符串。例如目录/aaa/bbb/下不存在/aaa/bbb/c.c，则pdir指向/aaa/bbb的元数据，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastelem&lt;/code&gt;=’c.c’&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件操作：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_create(const char *path, struct File **pf)&lt;/code&gt;: 创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;文件/目录，如果成功，将该文件或目录的元数据指针放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pf&lt;/code&gt;中。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_open(const char *path, struct File **pf)&lt;/code&gt;: 打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;， 如果成功，将该文件元数据地址赋给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pf&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_read(struct File *f, void *buf, size_t count, off_t offset)&lt;/code&gt;: 从文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt;位置（字节为单位）开始， 读取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;个字节到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt;中，返回实际读取字节数。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_write(struct File *f, const void *buf, size_t count, off_t offset)&lt;/code&gt;: 向文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt;位置开始，写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;个字节，数据的来源是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt;。 如果写的时候文件的大小超过了它已分配的块就要扩展文件。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_free_block(struct File *f, uint32_t filebno)&lt;/code&gt;: 删除文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;个块。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_truncate_blocks(struct File *f, off_t newsize)&lt;/code&gt;: 将文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;截短到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newsize&lt;/code&gt;的大小。具体操作是，计算原来文件具有的块数和新的块数，将超过新块数的部分释放掉。如果新的大小已经小于10块，则不需要间接索引了，释放掉间接索引块&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_set_size(struct File *f, off_t newsize)&lt;/code&gt;: 设置文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的大小为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newsize&lt;/code&gt;,自动截短或扩展。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_flush(struct File *f)&lt;/code&gt;: 将文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的数据和元数据写回磁盘，遍历文件的所有块，将所有的脏块写回磁盘。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;file_block_walk&quot;&gt;file_block_walk（）&lt;/h3&gt;

&lt;p&gt;查找文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;个块的磁盘地址（通过该文件元数据中的索引来查找），将该索引的地址存放到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ppdiskbno&lt;/code&gt;中。如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;置位，必要时分配间接索引页，否则返回错误信息。函数的过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;，是否在直接索引支持的范围内（0-9），如果是，就直接将ppdiskbno赋为直接索引上对应的条目的地址，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp; (f-&amp;gt;f_direct[filebno])&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;大于9，但是小于1034, 即文件系统可以支持的文件最大块数
    &lt;ul&gt;
      &lt;li&gt;如果间接索引块还没有分配，要检查&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;，如果alloc为0，返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E_NOT_FOUND&lt;/code&gt;表示找不到索引条目。&lt;/li&gt;
      &lt;li&gt;如果alloc为1：
        &lt;ul&gt;
          &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc_block&lt;/code&gt;为间接索引分配一个块， 如果分配错误，返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E_NO_DISK&lt;/code&gt;。&lt;/li&gt;
          &lt;li&gt;分配成功，则将间接索引链接到这个块上，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f-&amp;gt;f_indirect = blockno&lt;/code&gt;，这样查询10号以后的块时，首先查找&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f-&amp;gt;f_indirect&lt;/code&gt;得到索引块的地址，然后在索引块上找到对应的直接索引条目，根据该条目的值找到物理块号。&lt;/li&gt;
          &lt;li&gt;分配好之后，还要将索引块初始化为全0，表示这些文件块还没有分配和映射。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;无论是新分配的，还是原来就存在的，都要将间接索引块上对应的索引条目地址存放到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ppdiskbno&lt;/code&gt;中。 &lt;strong&gt;如何获得索引块上对应的条目地址呢？&lt;/strong&gt; 首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f-&amp;gt;f_indirect&lt;/code&gt;给出索引块的物理地址，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diskaddr(f-&amp;gt;f_indirect)&lt;/code&gt;就可以知道它的虚拟地址，也就是这个块上第一个索引条目的地址。这个虚拟地址再加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;在索引块上的偏移量就可以得到索引条目的虚拟地址，代码上有两种实现方式：
        &lt;ol&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(uintptr_t*) diskaddr(f-&amp;gt;f_indirect)&lt;/code&gt;将索引块的虚拟地址转为JOS的指针类型，指针可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[i]&lt;/code&gt;操作符来取得第i个数据，这里i应该是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno-10&lt;/code&gt;, 因为是索引块上的第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno-10&lt;/code&gt;条索引，最后用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;取址。&lt;/li&gt;
          &lt;li&gt;首先用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; diskaddr(f-&amp;gt;f_indirect)&lt;/code&gt;获得第一个索引条目的虚拟地址，然后加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(filebno-10)*4&lt;/code&gt;就得到第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno-10&lt;/code&gt;的地址，因为每个索引条目大小是4个字节。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;超过1034，是无效的，返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E_INVAL&lt;/code&gt;，否则返回0，表示成功。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;file_block_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ppdiskbno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here.&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ppdiskbno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_direct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1034&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_indirect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_NOT_FOUND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alloc_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
					&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_NO_DISK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_indirect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diskaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ppdiskbno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diskaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_indirect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        
       &lt;span class=&quot;c1&quot;&gt;//或者 *ppdiskbno = diskaddr(f-&amp;gt;f_indirect)+ (filebno-10)*4;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_INVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;file_get_block&quot;&gt;file_get_block()&lt;/h3&gt;

&lt;p&gt;file_get_block在file_block_walk的基础上，更进一步地，获取文件块对应的物理块号，并将物理块在文件系统进程中对应的虚拟地址保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blk&lt;/code&gt;中，过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_block_walk&lt;/code&gt;获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filebno&lt;/code&gt;个块的索引条目地址，保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slot&lt;/code&gt;中，要把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;设置为1，表示如果需要用到间接索引但索引块还未分配时要自动分配。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flie_block_walk&lt;/code&gt;返回值小于0，表示发生了错误，返回对应的错误码。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slot&lt;/code&gt;的值为0，即该文件逻辑块还没有分配到具体的物理块，可能是文件被创建或者被扩展等，要为该文件块分配一个物理块，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc_block()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;如果分配错误应返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E_NO_DISK&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;分配成功，则令对应的索引条目值为返回的物理块号，这样文件块就被映射到物理块上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;无论文件块原来是否已经分配，将物理块对应的虚拟地址保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blk&lt;/code&gt;中。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*slot&lt;/code&gt;是对应的物理块号，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diskaddr(*slot)&lt;/code&gt;就可以找到虚拟地址，将它保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blk&lt;/code&gt;中，成功返回0.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;file_get_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here.&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//slot = 索引条目的地址，*slot = 文件块对应的物理块号码&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_block_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filebno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_NO_DISK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diskaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查-3&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make grade&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_get_block&lt;/code&gt;OK，代码正确。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;todo5&quot;&gt;TODO5:&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;•在fs/serv.c中实现serve_read 。&lt;/p&gt;

  &lt;p&gt;•serve_read的大量操作将由fs / fs.c中已经实现的file_read来完成。 serve_read只需提供RPC接口即可读取文件。 查看serve_set_size中的注释和代码，以大致了解服务器功能的结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;请求文件系统服务的过程&quot;&gt;请求文件系统服务的过程&lt;/h3&gt;

&lt;p&gt;文件系统进程内部实现了对文件的各种操作，但是用户进程无法直接调用这些函数，因为它们是在文件系统进程的内存空间内。这时，需要采用&lt;strong&gt;进程间通信（IPC机制）&lt;/strong&gt;来在进程之间交换数据或者方法。JOS中，使用主从式架构来进行文件系统和其他进程之间的通信。通常，使用IPC进行数据交换的两个进程可以被分为服务端和用户端，客户端向服务器发出请求，服务器进行处理之后回应请求。JOS用建立在IPC基础上的远程过程调用（RPC）来进行通信。RPC在两个应用之间建立TCP连接，然后客户端应用将过程调用的参数序列化成二进制数据之后发送给服务端，服务端反序列化之后进行过程调用，返回值再序列化后发送回客户端。&lt;/p&gt;

&lt;p&gt;JOS的文件系统调用过程是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/report/OS6.png&quot; alt=&quot;image-20191213134403520&quot; style=&quot;zoom: 40%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;底层实际上是进程间通信。&lt;/p&gt;

&lt;p&gt;文件系统的相关数据结构有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件描述符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fd&lt;/code&gt;： 文件所在的设备id（因为一个文件系统可以跨多个设备），是否打开, 以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd_offset&lt;/code&gt;文件的光标等。&lt;/li&gt;
  &lt;li&gt;设备描述符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dev&lt;/code&gt;： 设备上各种操作调用的入口，设备名字和设备id。&lt;/li&gt;
  &lt;li&gt;打开文件描述符列表&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenFile&lt;/code&gt;结构，由内核维护的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opentab&lt;/code&gt;数组，保存了文件元数据的地址，文件打开状态，文件id以及磁盘上文件描述符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fd&lt;/code&gt;结构的指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;结构（文件元数据）：维护文件重要信息，完成逻辑块到物理块的映射等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_4_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&quot; alt=&quot;技術分享圖片&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文件描述符表映射在磁盘的0xD0000000处，文件描述符结构中包含了设备id，当进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd.c&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;时，将传入文件描述符号，通过文件描述符号找到对应地&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fd&lt;/code&gt;结构体，进而查找设备，设备用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dev&lt;/code&gt;结构来描述，结构体中包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev_read&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev_write&lt;/code&gt;等设备读、写函数的指针。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devfile_read&lt;/code&gt;函数定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file.c&lt;/code&gt;中，它将调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc()&lt;/code&gt;向服务器进程发起请求。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc()&lt;/code&gt;函数专门负责与文件系统进程进行通信，它建立在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt;机制上。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc.c&lt;/code&gt;封装了两个函数——&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_send( envid_t to_env, uint32_t val, void *pg, int perm )&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_recv( envid_t *from_env_store, void *pg, int *perm_store )&lt;/code&gt;，允许与某一个环境进行数据交换，交换的消息包含两个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1个32位的值&lt;/li&gt;
  &lt;li&gt;可选的页映射关系&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val&lt;/code&gt;是交换的数值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pg&lt;/code&gt;参数表示发送进程希望与接收进程共享&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pg&lt;/code&gt;对应的物理页，并且在接收进程中，对该页的权限是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perm&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;文件系统实现了一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fspic&lt;/code&gt;数据结构：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsipc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_open&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXPATHLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_omode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_set_size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_read&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsret_read&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_write&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_stat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsret_stat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXNAMELEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret_isdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statRet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_flush&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_remove&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXPATHLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Ensure Fsipc is one page&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它是一个联合，其中的各种结构体保存了对应的文件操作需要的参数，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc.read&lt;/code&gt;就有要读取的文件的id以及读取的大小&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_n&lt;/code&gt;. &lt;strong&gt;所以，在进程与文件系统通信的时候，两者可以共享一个保存了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fsipc&lt;/code&gt;结构的页面，从而实现参数的传递。&lt;/strong&gt; 在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file.c&lt;/code&gt;中，这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fspic&lt;/code&gt;结构的变量名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fspicbuf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devfile_read&lt;/code&gt;函数接收文件id以及读取大小，设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fspicbuf&lt;/code&gt;中对应的字段，然后调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc()&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc&lt;/code&gt;接收两个参数，一个是文件操作的类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt;，另一个是虚拟地址，这里应该传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf&lt;/code&gt;, 然后它会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_send()&lt;/code&gt;，其中要交换的32位值就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt;，对于文件读取，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt;置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSREQ_READ&lt;/code&gt;。然后继续调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_recv&lt;/code&gt;等待文件系统响应。当文件系统响应后，把结果依次返回给用户进程。&lt;/p&gt;

&lt;p&gt;在服务端，文件系统中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve()&lt;/code&gt;会循环调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_recv()&lt;/code&gt;监听请求，接收到请求之后，它会解析请求中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt;参数，然后具体分发到对应的handler。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt;和handler的对应关系是：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fshandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Open is handled specially because it passes pages&lt;/span&gt;
	&lt;span class=&quot;cm&quot;&gt;/* [FSREQ_OPEN] =	(fshandler)serve_open, */&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;serve_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_STAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;serve_stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_FLUSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fshandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serve_flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fshandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serve_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_SET_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fshandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serve_set_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_SYNC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;serve_sync&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_recv()&lt;/code&gt;时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve&lt;/code&gt;会传入一个参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsreq&lt;/code&gt;，它表示文件系统接收请求进程的共享页，要将共享页映射到虚拟内存的什么位置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsreq&lt;/code&gt;的定义是：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Virtual address at which to receive page mappings containing client requests.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsipc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsipc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ffff000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fsipc&lt;/code&gt;类型的指针。通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fsipc&lt;/code&gt;，文件系统可以接收来自客户进程的参数。&lt;/p&gt;

&lt;p&gt;从对应的handler返回后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve()&lt;/code&gt;函数也负责调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_send()&lt;/code&gt;将结果返回给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc&lt;/code&gt;。其中，交换的32位数据就是各个handler的返回状态，例如0表示成功，-E_NO_DISK表示磁盘空间不足等。&lt;strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;中，因为文件系统与客户进程共享&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsreq&lt;/code&gt;数据结构，那么它可以将读取出来的文件数据放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsreq.readRet&lt;/code&gt;中，这相当于一个块的缓冲区，让用户去读取。&lt;/strong&gt; 另外，如果调用的类型是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSREQ_OPEN&lt;/code&gt;， 还会将文件描述符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fd&lt;/code&gt;结构所在的页地址放到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pg&lt;/code&gt;中，与用户进程共享。&lt;/p&gt;

&lt;h3 id=&quot;serve_set_size阅读&quot;&gt;serve_set_size()阅读&lt;/h3&gt;

&lt;p&gt;这个函数是将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.c&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_set_size()&lt;/code&gt;函数封装成一个handler，所有的handler调用入口都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve&lt;/code&gt;函数。除了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve_open&lt;/code&gt;以外，所有的handler都只接受两个参数，一个是服务请求者的进程ID（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;envid&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whom&lt;/code&gt;），另一个是与请求者共享的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsreq&lt;/code&gt;页，上面保存了调用的参数。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;serve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ipc_recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fs req %d from %08x [page %08x: %s]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uvpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGNUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// All requests must contain an argument page&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Invalid request from %08x: no argument page&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// just leave it hanging...&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FSREQ_OPEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serve_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ARRAY_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Invalid request code %d from %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_INVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ipc_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;whom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sys_page_unmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve_set_size&lt;/code&gt;中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsreq&lt;/code&gt;union中只包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_size&lt;/code&gt;结构体，可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req-&amp;gt;req_fileid&lt;/code&gt;获取文件id，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req-&amp;gt;req_size&lt;/code&gt;获取要设置的文件大小。&lt;/p&gt;

&lt;p&gt;首先调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openfile_lookup&lt;/code&gt;来判断该进程是否打开了该文件。&lt;strong&gt;内核维护了系统中所有被打开的文件在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opentab&lt;/code&gt;数组中，而每一个进程也维护了自己打开文件的描述符&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果进程未打开文件，不可以调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_file_size()&lt;/code&gt;，返回错误码。否则，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openfile_lookup&lt;/code&gt;会将该文件的描述符保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o&lt;/code&gt;中，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o-&amp;gt;o_file&lt;/code&gt;就可以获取该文件的元数据指针。直接调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_set_size&lt;/code&gt;并返回返回值即可。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_size&lt;/code&gt;不需要为用户进程提供文件数据，只需要交换一个操作成功与否的状态信息。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Set the size of req-&amp;gt;req_fileid to req-&amp;gt;req_size bytes, truncating&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// or extending the file as necessary.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;serve_set_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_set_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpenFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;serve_set_size %08x %08x %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Every file system IPC call has the same general structure.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Here's how it goes.&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// First, use openfile_lookup to find the relevant open file.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// On failure, return the error code to the client with ipc_send.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;openfile_lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Second, call the relevant file system function (from fs/fs.c).&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// On failure, return the error code to the client.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_set_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;serve_read&quot;&gt;serve_read()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve_read&lt;/code&gt;处理读取文件的请求。它基于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.c&lt;/code&gt;中实现的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_read&lt;/code&gt;函数，接收进程的id以及调用参数结构&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fsipc&lt;/code&gt;，从文件的当前光标处读取文件的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_n&lt;/code&gt;个字节，到缓冲区&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readRet.ret_buf&lt;/code&gt;中，并更新文件光标的位置。如果成功，返回实际读取的字节数，否则返回错误号码。&lt;/p&gt;

&lt;p&gt;它的实现过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先从与客户端共享的调用参数页&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt;中，获取调用参数。因为是read操作，所以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc&lt;/code&gt;中保存的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REQ_READ&lt;/code&gt;结构体：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_read&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回的时候，要填充&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fspic&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readRet&lt;/code&gt;结构体中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret_buf&lt;/code&gt;，而因为缓冲区的大小只有一页，所以一次devfile_read调用读取的字节数不可以超过4096字节。readRet结构体的定义：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsret_read&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openfile_lookup&lt;/code&gt;找到该打开文件的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openFile&lt;/code&gt;结构体。如果返回值小于0，说明发生错误，返回错误码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenFile&lt;/code&gt;结构体中的o_file保存了文件的元数据指针，o_fd指向磁盘上的文件描述符结构&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fd&lt;/code&gt;，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fd&lt;/code&gt;保存了fd_offset,表示文件当前的光标位置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_read()&lt;/code&gt;，它需要四个参数：文件元数据指针，读取数据的缓冲区，读取数据字节数，读取开始的offset。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;调用隐式地从文件光标处读取n个字节，所以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt;参数可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o-&amp;gt;o_fd-&amp;gt;fd_offset&lt;/code&gt;获得。缓冲区是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret-&amp;gt;ret_buf&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读取失败的话返回错误码，否则将文件光标移动到读取完成的位置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回实际读取的字节数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;serve_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsipc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsret_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readRet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpenFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;serve_read %08x %08x %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Lab 5: Your code here:&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;openfile_lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		 
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查-4&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_read&lt;/code&gt;OK， 实现正确。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;todo6&quot;&gt;TODO6:&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;​     在fs/serv.c中实现serve-write，在lib/file.c中实现devfile-write&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;serve_write&quot;&gt;serve_write()&lt;/h3&gt;

&lt;p&gt;根据注释，serve_write()的功能应该是接收进程的id&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;envid&lt;/code&gt;和写请求的参数：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_write&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_buf&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_n&lt;/code&gt;个字节的内容写到对应文件的光标开始处。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_buf&lt;/code&gt;的大小是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGSIZE-(sizeof(int) + sizeof(size_t))&lt;/code&gt;， 这是为了保证&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc&lt;/code&gt;结构可以与页的大小对齐。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_n&lt;/code&gt;的大小只能小于或等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_buf&lt;/code&gt;的固定大小。也就是一次请求不会超过一个块。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve_write&lt;/code&gt;可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_write()&lt;/code&gt;来实现，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_write&lt;/code&gt;没有大小的限制，传给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_write&lt;/code&gt;的count大小只要不要超过文件最大大小的范围即可。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_write&lt;/code&gt;也已经提供了自动扩展文件大小的功能。根据函数的语义，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve_write()&lt;/code&gt;的实现为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;serve_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fsreq_write&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpenFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;serve_write %08x %08x %08x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;openfile_lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;devfile_write&quot;&gt;devfile_write()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devfile_write()&lt;/code&gt;处理用户程序发出的写请求，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_n&lt;/code&gt;不能超过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req_buf&lt;/code&gt;大小的条件在这个函数中检查。它将文件的id，请求写字节数和缓冲区保存到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;结构中，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc()&lt;/code&gt;函数发送ipc请求，并共享&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf&lt;/code&gt;页传递参数，把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc&lt;/code&gt;的返回值直接返回给用户进程。&lt;/p&gt;

&lt;p&gt;decfile_write的实现过程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;判断请求的字节数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;是否比缓冲区大小（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGSIZE - (sizeof(int) + sizeof(size_t)&lt;/code&gt;)大，如果超出，设置为缓冲区大小。&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf.write.req_fileid&lt;/code&gt;保存为用户进程请求的文件id。由于用户进程传给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devfile_write&lt;/code&gt;的是文件的描述符指针，所以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd-&amp;gt;fd_file.id&lt;/code&gt;来获得该文件id。&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf.write.req_n&lt;/code&gt;设置为请求字节数n（不超过缓冲区大小）&lt;/li&gt;
  &lt;li&gt;将用户传递进来的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt;中的前&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;个字节，复制到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf.write.req_buf&lt;/code&gt;中，这个复制使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memmove&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc()&lt;/code&gt;发起请求并返回。 这个调用的类型为写操作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSREQ_WRITE&lt;/code&gt;， 操作类型将由文件系统的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve()&lt;/code&gt;接收，分发到对应的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve_write&lt;/code&gt;函数。它不需要从文件系统那里共享页（因为不需要读取文件的内容），所以共享页虚拟地址为NULL。（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipc&lt;/code&gt;会在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_send&lt;/code&gt;的时候与文件系统共享&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsipcbuf&lt;/code&gt;页）。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;devfile_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Make an FSREQ_WRITE request to the file system server.  Be&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// careful: fsipcbuf.write.req_buf is only so large, but&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// remember that write is always allowed to write *fewer*&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// bytes than requested.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// LAB 5: Your code here&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    	&lt;span class=&quot;n&quot;&gt;fsipcbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_fileid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;fsipcbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;memmove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsipcbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsipc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FSREQ_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查-5&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;本次实验所有实现的函数检查都&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OK&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;文件系统负责文件的管理，它通过索引、链表、连续分配等方式组织文件，将文件内的逻辑地址映射到磁盘上的物理块地址；它通过bitmap、空闲块链表等数据结构维护磁盘上的空闲块，实现对磁盘空闲空间的管理；它直接与设备驱动程序（JOS）或者间接与设备驱动程序（UNIX系统中，设备驱动程序的操作封装为系统调用）交互，并通过逻辑地址到物理地址的转换，为用户提供了方便简单且统一的接口，以及一个直观的文件系统界面。&lt;/p&gt;

&lt;p&gt;JOS的文件系统通过bitmap来管理空闲空间，当文件系统的大小为3GB时，bitmap的大小为24块。通过间接索引结构来组织文件，文件元数据中保存索引，来完成文件逻辑地址到磁盘物理地址的转换。文件系统中的每一个文件都有一个id标识，保存在文件描述符中，文件描述符表位于磁盘上，描述了文件的id、是否打开、设备以及偏移位置等。内核维护打开的文件描述符表，该结构可以通过打开的文件id找到对应的文件描述符，并保存了文件的元数据指针等变量。&lt;/p&gt;

&lt;p&gt;文件块的读取是按需读取的，只有当一个块被用户请求时，文件系统引用该块对应的虚拟地址，会发生页错误，然后才将该块从磁盘上读取到内存。文件系统拥有IO权限，所以可以访问设备驱动程序，调用它的读和写函数。 文件的修改用了 延迟写回的策略， 修改暂时修改在内存中，只有在必要时，会将PTE_D标记为脏的内存页面写回到磁盘上。&lt;/p&gt;

&lt;p&gt;JOS中的文件系统是一个特殊的用户进程，它将磁盘地址映射到自己的虚拟地址空间上进行方便的管理，并通过自定义页错误处理程序完成磁盘块到内存的数据转移。通过IPC进程间通信机制，使得用户进程可以调用定义在文件系统进程内的过程，从而为用户进程提供系统调用的接口。&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="Lab Report" /><category term="OS" /><category term="JOS" /><summary type="html">Lab6：文件系统实现 JOS操作系统提供了一个简单的文件系统，它可以满足基本功能：创建，读取，写入，删除和以分层目录结构来组织文件。但并未提供文件所有权、用户权限的概念，不支持硬链接、符号链接、时间戳或特殊设备文件等，它提供的保护仅能捕获错误。</summary></entry><entry><title type="html">MIT 6.828 JOS 内存管理详解 操作系统实验5</title><link href="http://localhost:4000/lab%20report/2020/02/01/OS5memory/" rel="alternate" type="text/html" title="MIT 6.828 JOS 内存管理详解 操作系统实验5" /><published>2020-02-01T00:00:00+08:00</published><updated>2020-02-01T00:00:00+08:00</updated><id>http://localhost:4000/lab%20report/2020/02/01/OS5memory</id><content type="html" xml:base="http://localhost:4000/lab%20report/2020/02/01/OS5memory/">&lt;p&gt;本文详解JOS操作系统虚拟内存的结构，以及内存管理单元的结构与实现。
在这次实验中，将探索以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;计算机启动时如何开启虚拟内存&lt;/li&gt;
  &lt;li&gt;程序虚拟地址空间的结构&lt;/li&gt;
  &lt;li&gt;如何将内核物理地址与虚拟地址映射&lt;/li&gt;
  &lt;li&gt;访问一个虚拟地址的时候，会发生什么&lt;/li&gt;
  &lt;li&gt;如何管理内存空闲空间&lt;/li&gt;
  &lt;li&gt;如何保护特定的代码和数据&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;操作系统lab5-内存管理&quot;&gt;操作系统lab5： 内存管理&lt;/h1&gt;

&lt;p&gt;在lab1中，我们看到JOS 物理内存的结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/OS5-2.png&quot; alt=&quot;address space&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最初物理内存只有1MB， 之后扩展到了4GB，这时物理内存的640KB 到1MB之间就成为IO hole，是不可用的，用来分配给外部IO设备，如上图，640KB 到1MB之间被分配给了VGA Display、BIOS ROM以及其他的外部设备，称为IO hole。在JOS中，从0x0到640KB这部分称为 basemem，是可用的， 1MB以上的空间称为extented memory，也是可用的。&lt;/p&gt;

&lt;p&gt;为了更有效地管理和使用内存空间，JOS使用了虚拟内存，虚拟内存通过对程序存储地址与真实内存物理地址的解耦，有效解决了内存大小相对于大量用户程序所需空间不足的问题。引入虚拟内存之后，需要解决如何将多个程序分配到物理内存上，以及程序的虚拟地址如何与物理地址映射的问题。JOS通过分页的方式来管理内存和虚拟地址空间 ，将程序地址空间分为固定大小的页，将内存分为同样大小的页框，以页为单位将程序分配到内存物理空间上。页表记录了一个虚拟页对应的物理页框，以及这些页的相关信息，当程序执行中访问一个虚拟地址时，首先要访问它的页表，然后从页表中找到对应的真实地址，再访问真实的物理地址。&lt;/p&gt;

&lt;p&gt;在操作系统中，页表的管理、从虚拟地址到物理地址的转换、页面的分配回收以及缓存的管理等等，都是由内存管理单元(MMU)来完成的。内存管理与虚拟内存对用户是不可见的。&lt;/p&gt;

&lt;p&gt;在这次实验中，将探索以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;计算机启动时如何开启虚拟内存&lt;/li&gt;
  &lt;li&gt;程序虚拟地址空间的结构&lt;/li&gt;
  &lt;li&gt;如何将内核物理地址与虚拟地址映射&lt;/li&gt;
  &lt;li&gt;访问一个虚拟地址的时候，会发生什么&lt;/li&gt;
  &lt;li&gt;如何管理内存空闲空间&lt;/li&gt;
  &lt;li&gt;如何保护特定的代码和数据&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jos的虚拟地址空间布局&quot;&gt;JOS的虚拟地址空间布局&lt;/h3&gt;

&lt;p&gt;在lab1中，我们追踪了开机时bootloader加载内核的过程，加载完成后，物理内存的布局为：（图片来自&lt;a href=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/）&quot;&gt;https://blog-1253119293.cos.ap-beijing.myqcloud.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_1_physical_memory.png&quot; alt=&quot;物理内存分布&quot; style=&quot;zoom: 67%;&quot; /&gt;图片来自https://blog-1253119293.cos.ap-beijing.myqcloud.com/&amp;lt;/img&amp;gt;&lt;/p&gt;

&lt;p&gt;JOS用了手写的内存映射，将物理地址0x00000000-0x00400000之间4MB的空间映射到了虚拟地址0xf0000000-0xf0400000处。0xf0000000即为在虚拟地址空间中内核部分的起始。&lt;/p&gt;

&lt;p&gt;真正开启虚拟内存之后，对于内核和用户程序来说，虚拟地址的布局在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memlayout.h&lt;/code&gt;中定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;/*&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;                                &lt;span class=&quot;n&quot;&gt;Permissions&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                                                    &lt;span class=&quot;n&quot;&gt;kernel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;Remapped&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Physical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;KERNBASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;----&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xf0000000&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;--+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;KSTACKTOP&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;CPU0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Kernel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-|&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;Invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKGAP&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;CPU1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Kernel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-|&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;Invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKGAP&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;MMIOLIM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xefc00000&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;--+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapped&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;O&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MMIOBASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xef800000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Page&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Table&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;UVPT&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;----&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xef400000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;RO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PAGES&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;UPAGES&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;----&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xef000000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;RO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENVS&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UTOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UENVS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xeec00000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UXSTACKTOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-/&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xeebff000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;USTACKTOP&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;---&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xeebfe000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;Normal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xeebfd000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;                              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;                              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;                              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;Program&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Heap&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;UTEXT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00800000&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;PFTEMP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;UTEMP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00400000&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;--+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-|&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STAB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;USTABDATA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;----&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00200000&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;--+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[KERNBASE, 4Gig ] :  这部分映射到物理内存上中断向量表、引导扇区代码、IOhole以及内核代码、数据。在这部分，一个虚拟地址 - KERNBASE就是它的物理地址。内核部分会被同样地映射到每个进程的高地址空间，用户是没有权限访问的。&lt;/p&gt;

&lt;p&gt;KERNBASE往下是进程的地址空间，如之前报告中所述，进程地址空间的高处是内核栈，这部分地址是用户模式下不可访问的。&lt;/p&gt;

&lt;p&gt;[MMIOBASE, MMIOLIM ] : 这部分空间属于内存映射的IO设备，与IO设备通信要陷入内核完成，因此用户模式也不可访问。&lt;/p&gt;

&lt;p&gt;[UVPT, ULIM ] : 从ULIM往下直到UTOP是用户模式下只读的地址。UVPT到ULIM的这部分是当前的页目录，用户可以读取页表知道一个虚拟地址所在的物理页面，但不可操纵页表。&lt;/p&gt;

&lt;p&gt;[UPAGES, UVPT] ：这部分对应着&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组在物理内存中存放的位置，用户也可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uvpt[n].pp_ref&lt;/code&gt;来知道某个物理页框是否已经被占用，但也不可操纵。&lt;/p&gt;

&lt;p&gt;[0, UTOP] : 这部分才真正是用户模式下可以读写的地址空间，它包括了用户程序的代码段、数据段、堆栈等。&lt;/p&gt;

&lt;h3 id=&quot;jos中的三种地址&quot;&gt;JOS中的三种地址&lt;/h3&gt;

&lt;p&gt;JOS中有三种地址： 逻辑地址(virtual address)， 线性地址(linear address),  物理地址(physical address). 逻辑地址是程序编译链接之后变量的符号，实际上，逻辑地址是变量的段内偏移。 线性地址是逻辑地址经过保护模式的段地址变换之后的虚拟地址，线性地址=段首地址+逻辑地址。物理地址则是内存存储单元的编址，它会被直接送到内存的地址线上进行读写。&lt;/p&gt;

&lt;p&gt;逻辑地址到线性地址的变换在保护模式下自动完成。如果没有开启页式地址转换（Paging），那么线性地址就是物理地址，如同我们在lab 1中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov %eax, cr3&lt;/code&gt;之前看到的一样。如果开启分页，线性地址就会按查询页表的方式转换成物理地址。&lt;strong&gt;后面的实验内容中，我们直接将线性地址称为虚拟地址。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;jos的页表结构&quot;&gt;JOS的页表结构&lt;/h3&gt;

&lt;p&gt;页表记录了从虚拟地址到真实物理地址之间的映射，JOS的页表结构、虚拟地址组成定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中，它使用的是一个两级页表：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;la&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;part&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;structure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;follows&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// +--------10------+-------10-------+---------12----------+&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// | Page Directory |   Page Table   | Offset within Page  |&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// |      Index     |      Index     |                     |&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// +----------------+----------------+---------------------+&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  \---------- PGNUM(la) ----------/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;地址最高10位表示页表目录，中间10位表示页表索引，最后12位表示在一个页面内的偏移，因此，页面总数为$2^{10}$ *$2^{10}$=1024x1024，页面大小为2^12=4096字节。&lt;/p&gt;

&lt;p&gt;JOS使用两级页表，将全部的地址空间分为了一个页表目录和1024个页表，由于页表有1024个条目，每个条目的长度是4字节，则&lt;strong&gt;每个页表刚好就占一个页面&lt;/strong&gt;，因此页表的地址只需要20位来区分。所以，在页面目录中，我们只需要20位来存放索引对应页表所在的物理地址，剩下的12位用来存放各种标志。页面目录中也含有1024条目，所以&lt;strong&gt;页面目录也只占一个页面&lt;/strong&gt;。所以在用户的虚拟地址中，只需要存放一份页面目录的镜像，就可以让用户程序访问到页表，而不需要将所有1024个页表都映射到用户的虚拟地址空间。&lt;/p&gt;

&lt;p&gt;一个页表目录条目（或者页表条目，一样的）的结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://plafer.github.io/img/x86_pgdir.png&quot; alt=&quot;pgdir entry&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个目录条目的前20位记录了一个页表的物理地址。访问一个虚拟地址时，首先根据前10位目录索引从page directory上找到相应的条目，取出前20位作为页表的物理地址，然后访问该页表，根据10位的页表索引找到页表上对应的物理地址（也是前20位，与PGSIZE对齐），这个20位的物理地址加上offset就得到了物理地址。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://plafer.github.io/img/x86-addr-format.gif&quot; alt=&quot;x86 addr format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://plafer.github.io/img/x86-addr-translation.gif&quot; alt=&quot;x86 addr translation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;条目剩下的低12位用来存放各种标志，来表示一个页表/页面的状态，所有的状态在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Page table/directory entry flags.&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define PTE_P		0x001	// Present
#define PTE_W		0x002	// Writeable
#define PTE_U		0x004	// User
#define PTE_PWT		0x008	// Write-Through
#define PTE_PCD		0x010	// Cache-Disable
#define PTE_A		0x020	// Accessed
#define PTE_D		0x040	// Dirty
#define PTE_PS		0x080	// Page Size
#define PTE_G		0x100	// Global
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，Present位是用来判断对应的页表或者条目是否存在物理内存中，如果存在则为1. 在后面的代码中，我们判断一个虚拟页是否与一个物理页框映射，即是否驻留在内存时，就可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry &amp;amp; PTE_P&lt;/code&gt;来判断。&lt;/p&gt;

&lt;h2 id=&quot;todo-1-physical-page-management-代码阅读&quot;&gt;TODO 1: Physical Page Management 代码阅读&lt;/h2&gt;

&lt;h3 id=&quot;mem_init&quot;&gt;mem_init()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init()&lt;/code&gt;在内核刚启动时调用，它的任务是在开机之后，设置好分页系统，并完成内核部分虚拟地址与物理地址的映射。目前只完成了一部分，它需要初始化的变量如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// These variables are set in mem_init()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Kernel's initial page directory&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Physical page state array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Free list of physical pages&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;是页表目录。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PageInfo&lt;/code&gt;是一个用来描述物理页框的结构体，它定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memlayout.h&lt;/code&gt;中, 由一个指向下一个节点的指针，和引用位构成。每一个物理页框都对应着一个PageInfo结构，引用位表示该页框是否已经被占用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组记录了所有物理页框（总共&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npages&lt;/code&gt;个）的信息，而为了分配页面时更快地找到一个空的页框，JOS还维护了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;链表，动态地保存所有空闲的页框。当需要分配页面时，从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;的头部指针获取第一个空闲页框，然后将头部指针后移；当有新的空闲页面时，将这个新页面的指针添加到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;中。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Next page on the free list.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// pp_ref is the count of pointers (usually in page table entries)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// to this page, for pages allocated using page_alloc.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Pages allocated at boot time using pmap.c's&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// boot_alloc do not have valid reference count fields.&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;具体实现如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Set up a two-level page table:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//    kern_pgdir is its linear (virtual) address of the root&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// This function only sets up the kernel part of the address space&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// (ie. addresses &amp;gt;= UTOP).  The user part of the address space&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// will be set up later.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// From UTOP to ULIM, the user is allowed to read but not write.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Above ULIM the user cannot read or write.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mem_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Find out how much memory the machine has (npages &amp;amp; npages_basemem).&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;i386_detect_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//检测机器有多少物理内存。&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Remove this line when you're ready to test this function.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mem_init: This function is not finished&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//////////////////////////////////////////////////////////////////////&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// create initial page directory.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//////////////////////////////////////////////////////////////////////&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Recursively insert PD in itself as a page table, to form&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// a virtual page table at virtual address UVPT.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// (For now, you don't have understand the greater purpose of the&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// following line.)&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Permissions: kernel R, user R&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UVPT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//////////////////////////////////////////////////////////////////////&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// The kernel uses this array to keep track of physical pages: for&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// each physical page, there is a corresponding struct PageInfo in this&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// array.  'npages' is the number of physical pages in memory.  Use memset&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// to initialize all fields of each struct PageInfo to 0.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;


	&lt;span class=&quot;c1&quot;&gt;//////////////////////////////////////////////////////////////////////&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Now that we've allocated the initial kernel data structures, we set&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// up the list of free physical pages. Once we've done so, all further&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// memory management will go through the page_* functions. In&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// particular, we can now map memory using boot_map_region&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// or page_insert&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;page_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;check_page_free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;check_page_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;check_page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在JOS开机的时候，我们会看到一句输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/OS5-1.png&quot; alt=&quot;image-20191127111815464&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给出了物理内存的可用空间，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt;是底部的basemem的大小（640K），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extended&lt;/code&gt;是extended memory的大小，是1MB以上的可用空间。检测是在函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i386_detect_memory()&lt;/code&gt;中完成的：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;i386_detect_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basemem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extmem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ext16mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Use CMOS calls to measure available base &amp;amp; extended memory.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// (CMOS calls return results in kilobytes.)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;basemem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nvram_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NVRAM_BASELO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;extmem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nvram_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NVRAM_EXTLO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ext16mem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nvram_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NVRAM_EXT16LO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Calculate the number of physical pages available in both base&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// and extended memory.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ext16mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ext16mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extmem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extmem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basemem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;npages_basemem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basemem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Physical memory: %uK available, base = %uK, extended = %uK&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basemem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalmem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basemem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意到读取basemem、extmem和ext16mem的大小使用了函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvram_read&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvram_read&lt;/code&gt;实际上又调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mc146818_read&lt;/code&gt;函数，这个函数通过IO端口0x70与0x71从实时时钟RTC中读取数据。RTC使用芯片mc146818，在系统电源关闭时，RTC仍保持工作，维护系统的日期和时间，当系统启动时，就从RTC中读取日期时间的基准值。时钟和这里的物理内存其实没有关系，但mc146818芯片中带有一个非易失性的RAM，也就是non-volatile-ram（nvram），系统的物理内存basemem和extmem的大小，都存放在这个芯片上，这样可以保证系统电源关闭时，这些信息不会被擦除。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i386_detect_memory&lt;/code&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvram_read&lt;/code&gt;从mc146818芯片中读取出basemem和extmem大小（以KB为单位），然后根据它们计算出内存总的可用空间以及总的页面数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npages&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npages_basemem&lt;/code&gt;。PGSIZE定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中，为4096字节。&lt;/p&gt;

&lt;p&gt;检测出可用内存大小之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;开始设置内核的页表。首先调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt;在物理内存中分配内核的页表。&lt;/p&gt;

&lt;h3 id=&quot;boot_alloc&quot;&gt;boot_alloc()&lt;/h3&gt;

&lt;p&gt;boot_alloc()只会在JOS初始化虚拟内存之前被调用一次，之后分配页面的时候都只会使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_allocator()&lt;/code&gt;. 之所以要写一个单独的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt;是因为： 在启动时需要将内核的物理地址映射到虚拟地址，这种映射需要通过访问内核的页表来实现，创建页表涉及到分配页表所在的页面，可是分配页面又是在虚拟内存设置好才可以做到。所以，JOS使用了一个单独的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt;，将需要分配的页面映射到一些固定的虚拟地址，并返回所分配的内容的起始虚拟地址。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//n表示需要分配的字节数&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// virtual address of next byte of free memory&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//result 用来保存分配的一片虚拟地址的起始地址&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Initialize nextfree if this is the first time.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 'end' is a magic symbol automatically generated by the linker,&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// which points to the end of the kernel's bss segment:&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// the first virtual address that the linker did *not* assign&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// to any kernel code or global variables.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                     
		&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Allocate a chunk large enough to hold 'n' bytes, then update&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// nextfree.  Make sure nextfree is kept aligned&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// to a multiple of PGSIZE.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERNBASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Out of memory!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextfree&lt;/code&gt;表示下一个未用的虚拟地址, 是一个静态变量。当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir = (pde_t *) boot_alloc(PGSIZE)&lt;/code&gt;时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextfree&lt;/code&gt;还未初始化，它会被初始化在内核.bss段的结束，并与页面大小4096B 对齐。&lt;/p&gt;

&lt;p&gt;这里使用了函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROUNDUP(char* a, uint32_t n)&lt;/code&gt;，它同&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROUNDDOWN&lt;/code&gt;一起在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type.h&lt;/code&gt;中定义，分别是求 a/n的向上和向下取整，因此，ROUNDUP可以用来将地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;对齐。&lt;/p&gt;

&lt;p&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt;保存&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextfree&lt;/code&gt;作为起始地址后，将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextfree&lt;/code&gt;向后移动&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;个字节（也要和PGSIZE对齐），作为下次分配的起始地址。&lt;/p&gt;

&lt;p&gt;在分配时，还要检查是否是一个合法的虚拟地址。 从上面JOS虚拟地址空间布局，我们知道&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextfree-KERNBASE&lt;/code&gt;实际上就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextfree&lt;/code&gt;的物理地址，这个物理地址不可超过内存可用的物理空间大小(页框总数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npages&lt;/code&gt;*页面大小&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGSIZE&lt;/code&gt;)，否则抛出错误。&lt;/p&gt;

&lt;p&gt;回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;中，&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将内核页表分配在虚拟地址空间中内核.bss段的后面，然后用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;将页表初始化为全0.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UVPT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在虚拟地址布局中，我们看到从[UVPT, ULIM]（大小为一个页表大小）这一段是用户和内核都可读的页表目录的复制，那么就要将虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UVPT&lt;/code&gt;映射到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;的真实物理地址上去， 而要完成这种映射，就是要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;页表目录中，对应虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UVPT&lt;/code&gt;的条目中，将页表地址改为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;的物理地址。 这样，当用户或内核访问UVPT与ULIM之间的虚拟地址时，就要首先访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;，查找&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uvpt&lt;/code&gt;对应的物理地址，然后发现该物理地址就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;所在的物理地址。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PDX(la)&lt;/code&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中定义，计算la对应的页表目录索引。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PADDR&lt;/code&gt;是将传入的虚拟地址减去&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;，得到物理地址。 PTE_U表示用户有权限（则内核也有权限），PTE_P表示物理地址存在。这个语句将页表目录中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UVPT&lt;/code&gt;起始的页面对应的条目置为页表目录的物理页面地址， 并设置用户可读。&lt;/p&gt;

&lt;p&gt;接下来，初始化&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt;将它分配在内核页表目录&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;之后，并用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;初始化为全0.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组用来一对一地记录每一个物理页框是否被占用，可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages[i].pp_ref&lt;/code&gt;来判断。&lt;/p&gt;

&lt;p&gt;之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_init()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;page_init&quot;&gt;page_init()&lt;/h3&gt;

&lt;p&gt;我们已经初始化了页表目录和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组，则&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_init()&lt;/code&gt;的任务就是初始化&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;，记录哪一些物理页框是空闲的，并设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;中每一个页框的结构。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;实际上只是一个PageInfo结构体，此结构体中包含了指向下一个的指针，也就是下一个空闲的页框。所以，我们可以遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组，将那些已经分配出去的页框&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp_ref&lt;/code&gt;置为1，将空闲的页框&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp_ref&lt;/code&gt;置为0，并让&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;指向这个页框，从而将它插入空闲页框链表。&lt;/p&gt;

&lt;p&gt;根据注释提示，第一个物理页框已经分配给中断向量表和其他的BIOS结构，basemem中剩下的部分([PGSIZE, npages_basemem*PGSIZE])还是空闲的。&lt;/p&gt;

&lt;p&gt;extmem中，我们刚才已经分配了一部分给内核，要知道分配了多少，我们可以调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc(0)&lt;/code&gt;来获取分配完&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;之后，下一个可用的虚拟地址，将它减去KERNBASE得到物理地址，再除以PGSIZE就得到分配出去的页框数目。&lt;/p&gt;

&lt;p&gt;IOhole部分，也就是从640KB到1MB之间的96个页面，都分配给了外部IO设备。IOhole和extmem是连续的，因此page_init的实现如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;page_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//  1) Mark physical page 0 as in use.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     This way we preserve the real-mode IDT and BIOS structures&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     in case we ever need them.  (Currently we don't, but...)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     is free.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     never be allocated.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//  4) Then extended memory [EXTPHYSMEM, ...).&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     Some of it is in use, some is free. Where is the kernel&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     in physical memory?  Which pages are already in use for&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//     page tables and other data structures?&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//num_alloc：在extmem区域已经被占用的页的个数&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_alloc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERNBASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//num_iohole：在io hole区域占用的页数&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_iohole&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//第一个页面已经被占用&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
	    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;npages_basemem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;npages_basemem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_iohole&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//从IOhole到extmem中已分配的部分&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//页面空闲，将pp_ref=0，将pp_link置为下一个空闲页面的指针，这样，当该页面被分配出去的时候，我们可以让page_free_list指向pp_link来将它从链表中移出。&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_link&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//将pages[i]插入到page_free_list的头部。&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;page_alloc&quot;&gt;page_alloc()&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;设置好之后，分配页面就不可以再调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt;了，必须调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_alloc&lt;/code&gt;通过在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_link&lt;/code&gt;查找空页框的方式来分配页面。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_alloc&lt;/code&gt;分配一个页面，返回该页面的PageInfo指针。它同时接收一个参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc_flags&lt;/code&gt;, 如果它的值为1（ALLOC_ZERO), 就将分配到的物理页面设置为全0。如果没有可用页框，则返回空指针NULL。所以该函数的步骤为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从page_free_list中取出一个空闲页框的PageInfo结构体。&lt;/li&gt;
  &lt;li&gt;将这个页框从page_free_list中移去，并将链表头指针指向下一个空闲页框。&lt;/li&gt;
  &lt;li&gt;修改取出的PageInfo相关信息，如果有ALLOC_ZERO, 修改该内存页。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;page_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//没有空闲页框，返回NULL。&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;//将第一个空闲页框分配出去&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//让page_free_list指向该页框的pp_link,也就是链表上的下一个空闲页框，从而将队首pop出去。&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_link&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alloc_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALLOC_ZERO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page2kva&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//用memset将该页面设置为全0.&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page2kva()&lt;/code&gt;函数是将传进去的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt;加上KERNBASE, 得到result的物理地址。 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt;对应的物理地址开始，一个页面大小的物理内存设置为0.&lt;/p&gt;

&lt;h3 id=&quot;page_free&quot;&gt;page_free()&lt;/h3&gt;

&lt;p&gt;这个函数将一个被分配的页框归还，只有当该页框的引用位pp_ref为0时，才可以调用：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;page_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Fill this function in&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Hint: You may want to panic if pp-&amp;gt;pp_ref is nonzero or&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// pp-&amp;gt;pp_link is not NULL.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_link&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_link&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;page_free_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt;是断言，用来判断条件是否满足，否则发出panic错误。当页框在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_alloc&lt;/code&gt;中被分配出去时，会将pp_link设置为NULL，而页框不再被使用时，pp_ref会置回0，只有这两个条件满足才可以调用page_free.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free&lt;/code&gt;只要简单地将页框插入到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;的表头即可，为此，将pp_link指向现在的链表头部：page_free_list, 然后将头部指针指向该页框（pp).&lt;/p&gt;

&lt;h2 id=&quot;todo-2--virtual-memory&quot;&gt;TODO 2:  Virtual Memory&lt;/h2&gt;

&lt;p&gt;参考&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pgdir_walk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_insert&lt;/code&gt;函数，实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_lookup&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_remove&lt;/code&gt;。首先阅读这三个函数的代码，为了方便解释代码，先看一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中提供的一些宏，以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap.h&lt;/code&gt;中提供的功能函数。&lt;/p&gt;

&lt;h3 id=&quot;宏与功能函数&quot;&gt;宏与功能函数&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;types.h&lt;/code&gt;中定义了与内存管理相关的类型：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//表示虚拟地址&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;physaddr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//表示物理地址&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Page numbers are 32 bits long.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppn_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//表示页面编号的类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//表示一个页表条目的类型&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//表示一个页目录中的条目的类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于一个虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;，如果它在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;以上，说明它是一个内核的虚拟地址，而内核部分是始终驻留在内存中的，我们可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap.h&lt;/code&gt;中定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PADDR(va)&lt;/code&gt;直接将其减去&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;得到物理地址。如果它不在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;上，那么就要通过MMU访问页表来将它转换成物理地址。相应的，如果是一个内核的物理地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pa&lt;/code&gt;, 才可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KADDR&lt;/code&gt;将它加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;得到虚拟地址。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmu.h&lt;/code&gt;中，定义了一些宏，方便从一个虚拟地址获得对应的页目录、页表条目信息以及物理地址：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGNUM(la)&lt;/code&gt;: 表示一个虚拟地址的页编号，因为每个页是4096字节，又编号是从0开始顺序编号的，只要将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;la&lt;/code&gt;右移12位。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PDX(la)&lt;/code&gt;：对应页目录索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PTX(la)&lt;/code&gt;: 对应页表索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGOFF(la)&lt;/code&gt;: 在页面内的偏移&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGADDR(d,t,o)&lt;/code&gt;: 从已知的页目录索引、页表索引和页内偏移还原一个虚拟地址。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PTE_ADDR(pte)&lt;/code&gt;: 从一个页目录条目或者一个页表条目中取出它的高20位物理地址部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap.h&lt;/code&gt;中，函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page2pa()&lt;/code&gt;实现了给出一个页面，获取这个页面开始处的物理地址； 函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pa2page()&lt;/code&gt;实现了给出一个与页大小对齐的物理地址，返回它所在的页面的PageInfo。&lt;/p&gt;

&lt;h3 id=&quot;pgdir_walk&quot;&gt;pgdir_walk()&lt;/h3&gt;

&lt;p&gt;这个函数的功能是，给出一个虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;， 访问两级页表，找到它对应的页表条目，返回页表条目的指针。但是，由于页表不是一直都整个驻留在内存中的，所以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的条目所在的页表页可能还不在内存中，这时，如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;，就返回空指针，否则就要使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_alloc()&lt;/code&gt;函数，分配这个页表页。&lt;/p&gt;

&lt;p&gt;这个过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;得到它的页目录索引&lt;/li&gt;
  &lt;li&gt;在页目录上根据索引找到对应条目&lt;/li&gt;
  &lt;li&gt;判断该条目的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;present&lt;/code&gt;位是否为1， 如果置位，说明对应的页表在内存中，否则不在
    &lt;ul&gt;
      &lt;li&gt;如果create置位，要在内存中为这个页表分配一个页框，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_alloc()&lt;/code&gt;.
        &lt;ul&gt;
          &lt;li&gt;如果分配不成功，只能返回NULL。&lt;/li&gt;
          &lt;li&gt;分配成功，要将这个页表页的引用数pp_ref 加上1， 因为我们现在正要从页表上查&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的条目。并且，还要在页目录中，记录这个页表的物理地址，设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;present&lt;/code&gt;为1，并设置权限为用户可读写。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt;为0，返回NULL。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;找到了页表后，计算&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的页表索引&lt;/li&gt;
  &lt;li&gt;获取页表上该条目，返回条目的地址。（&lt;strong&gt;这里所说的地址是该条目的虚拟地址&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pgdir_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//页偏移&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//页表页的基址（虚拟地址）&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//可能需要分配页表页&lt;/span&gt;
      
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dic_off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//用PDX获取va的页目录索引&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dic_entry_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dic_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//页目录中对应的条目的虚拟地址，等于页目录的起始地址+条目在页目录中的索引号&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dic_entry_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//*dic_entry_ptr获取目录条目中的内容，与PTE_P 判断present是否置位，也就是该页表是否在内存中，如果不在：&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//在内存中分配该页表页&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;new_page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//分配一个页表页，参数为1，表示该片内存被初始化为全0（之后会将该页表从磁盘读取到这片内存，这不是MMU的工作）&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//分配失败&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;new_page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//分配成功，则该页面的引用数要增加1.&lt;/span&gt;
                   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dic_entry_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page2pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 使用page2pa(newpage)获得该页的起始物理地址，将它存放在对应的页目录条目中，并且置present为1， 更改权限为用户可以读写。&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
     &lt;span class=&quot;c1&quot;&gt;//用PTX(va)宏，获取va对应的页表索引，这就是要返回的条目在页表中的偏移。&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;page_off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//page_base用来表示该页表页所在的虚拟地址。要获得此虚拟地址，首先要从页目录表上获得该页表页的物理地址，再用KADDR转换成虚拟地址。&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;page_base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dic_entry_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后三行代码最为关键，经过上面的判断和分配页表页，现在该页表页的物理地址已经存放在页目录对应的条目中了， 用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PTE_ADDR(*dic_entry_ptr)&lt;/code&gt;就可以从条目中取出该页表页的物理地址。用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KADDR&lt;/code&gt;可以将物理地址转换为页目录的虚拟地址，这时，其实将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_base+page_off&lt;/code&gt;就可以得到该条目的虚拟地址了。因此，最后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return &amp;amp;page_base[page_off]&lt;/code&gt;也可以替换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return page_base+page_off&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;boot_map_region&quot;&gt;boot_map_region()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt;的功能是，将虚拟地址[va, va+size]映射到物理地址[pa, pa+size]上，意思就是在页表中[va, va+size]对应的条目中设置物理地址为[pa, pa+size]。 这里va, pa,size都是保证与页面大小对齐的，size的单位是页。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perm&lt;/code&gt;参数给出了这块内存空间的权限。&lt;/p&gt;

&lt;p&gt;这个函数是用来“静态“地映射&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt;以上的用户只读空间的。过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历从[va, va+size]的每一个虚拟页，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pgdir_walk&lt;/code&gt;找到它在页表中的对应条目&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;将该条目的内容设置为 [pa , pa+size ]&lt;/td&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perm&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;PTE_P. 表示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;present&lt;/code&gt;置位，这些页面存在于内存中，并设置了权限。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;physaddr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nadd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nadd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nadd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nadd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgdir_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//Get the table entry of this page.&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
        
        
        &lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;page_insert&quot;&gt;page_insert()&lt;/h3&gt;

&lt;p&gt;这个函数是将一个物理页框&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;映射到虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;上。要考虑两种情况，一是该va已经映射到了其他的物理页框上，这时就要接触这个映射关系； 另一种是该va本来就映射到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;上了。过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pgdir_walk&lt;/code&gt;得到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;在页表上的条目。&lt;/li&gt;
  &lt;li&gt;如果找不到该条目，说明内存不足，返回错误码 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E_NO_MEM&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;要先让&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp-&amp;gt;pp_ref++&lt;/code&gt;，之后解释原因。&lt;/li&gt;
  &lt;li&gt;如果该条目已经存在，说明&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;本来已经映射到一个物理页框上，
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tlb_invalidate&lt;/code&gt;使该&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的页表条目失效，这样，才不会使进程在这个过程中访问到不正确的物理地址。&lt;strong&gt;这是因为进程会缓存它用到的页表，快速访问页表时，它先访问缓存中是否有该页表，如果没有，才从页目录去找&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_remove&lt;/code&gt;解除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;和原来物理页框的映射。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;无论之前该条目是否存在，现在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;已经不与任何物理页框绑定，将条目内容设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;的物理地址，设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;present&lt;/code&gt;为1，并设置权限为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;page_insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  
    &lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;pgdir_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//Get the mapping page of this address va.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E_NO_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp_ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;//If this virtual address is already mapped.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tlb_invalidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;page_remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page2pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;//Remember this step!&lt;/span&gt;
        
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个函数中，只用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(*entry) &amp;amp; PTE_P&lt;/code&gt;判断页表条目是否存在，来判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;是否已经有映射关系，但没有区分&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;是否与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;映射。如果我们将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp-&amp;gt;pp_ref++&lt;/code&gt;移到if块后面，那么当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;已经与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;映射时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;原来的引用数有可能为0，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;中，我们会不加判断地调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_remove&lt;/code&gt;，然后因为引用数为0，直接调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free&lt;/code&gt;将它释放掉。 既然释放了，它就会处在空闲链表&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp_ref&lt;/code&gt;应该保持为0. 我们之后再用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp-&amp;gt;pp_ref++&lt;/code&gt;时，就会让空闲链表管理出错，下一次分配页框时，可能在空闲链表中找到这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt;，但它是不可用的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下来我们实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_lookup&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_remove&lt;/code&gt;函数。&lt;/p&gt;

&lt;h3 id=&quot;page_lookup&quot;&gt;&lt;strong&gt;page_lookup()&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;这个函数的功能是给出虚拟地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;，找到它映射到的物理页框。如果传入的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pte_store&lt;/code&gt;不为NULL的话，就将该虚拟地址对应的页表条目指针存放到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pte_store&lt;/code&gt;中。实现过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pgdir_walk&lt;/code&gt;找到va对应的条目，这里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt;应该设置为0，即若va所在的页表页不在内存，我们也不分配它。&lt;/li&gt;
  &lt;li&gt;如果返回的是NULL，表示va所在的页表页不在内存，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;现在没有映射到物理页框，返回NULL。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的页表页在内存中，但是条目的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;present&lt;/code&gt;位为0，说明&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;没有映射到物理页框:
    &lt;ul&gt;
      &lt;li&gt;判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pte_store&lt;/code&gt;，如果不为NULL，将条目存放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pte_store&lt;/code&gt;中&lt;/li&gt;
      &lt;li&gt;返回NULL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PTE_ADDR&lt;/code&gt;从条目上获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的物理地址&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pa2page&lt;/code&gt;获取物理地址对应页框的PageInfo&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pte_store&lt;/code&gt;非空，将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pte&lt;/code&gt;保存，最后返回PageInfo&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;page_lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte_store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgdir_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//不存在，不分配&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//页表页不存在&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte_store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte_store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//页表页存在，但是va并不与一个物理页框映射&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
	&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pa2page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;page_remove&quot;&gt;page_remove()&lt;/h3&gt;

&lt;p&gt;这个函数的功能是解除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;与它对应的物理页框之间的映射关系。这不一定说明该物理页框已经空闲，可以回到空闲链表中被分配。因为该页框的引用数并不一定为0，例如在共享内存时，有可能不同进程会共享一部分物理内存，不同的虚拟地址会映射到同一个物理页框上。因此，这个函数的实现过程应该是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_lookup&lt;/code&gt;查找&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的物理页，并保存其页表条目的地址在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;pte&lt;/code&gt;中。&lt;/li&gt;
  &lt;li&gt;如果该&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;有映射到某个物理页框，解除映射：
    &lt;ul&gt;
      &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_decref&lt;/code&gt;，这里面做的是，将pp_ref减去1，如果等于0，可以调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free&lt;/code&gt;释放空间，将页框归还。&lt;/li&gt;
      &lt;li&gt;因为使用快速页表访问时，进程可能缓存了最近使用过的页表条目，所以要调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tlb_invalidate&lt;/code&gt;让这条&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;的缓存条目无效，否则进程会优先访问缓存中的条目，进而访问到非法的物理地址。&lt;/li&gt;
      &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;va&lt;/code&gt;对应的条目内容清0.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;page_remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pte_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;page_decref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tlb_invalidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//使TLB中可能缓存的这条页表条目无效&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查&quot;&gt;检查&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pmap.c&lt;/code&gt;中实现了几个函数对代码进行了检查。这些检查函数在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;中被调用，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check_page()&lt;/code&gt;是检查分页的基础功能是否已经实现好，包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_alloc()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_insert()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_remove()&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_lookup()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pgdir_walk()&lt;/code&gt; 以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;重新编译并启动&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qemu&lt;/code&gt;，看到控制台输出：&lt;/p&gt;

&lt;p&gt;” check_page() succeeded!” 表明实现是正确的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;todo-3-kernel-address-space&quot;&gt;TODO 3: Kernel Address Space&lt;/h2&gt;

&lt;p&gt;###完成mem_init()&lt;/p&gt;

&lt;p&gt;上面的函数已经完成了分页机制，页表也已经创建好。现在，我们就可以通过修改页表上的条目，完成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt;以上用户不可操作的空间与物理地址的映射。&lt;/p&gt;

&lt;p&gt;首先，将[UPAGES, UVPT]这部分虚拟地址映射到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组上，权限设置为内核与用户只读，相当于为用户保留了物理页框信息的拷贝。这样，虚拟地址空间上实际有两份&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;，一部分在KERNBASE以上，用户不可见，内核可读写，这一份就是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;刚开始分配的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;；另一份是为用户准备的只读拷贝，两者通过页表映射到同一片物理内存上，但这份拷贝设置的权限是只读，所以用户不能对这部分虚拟地址的内容进行操作；又因为用户不可访问KERNBASE上面的虚拟地址（在用户访问虚拟地址时，内核会判断虚拟地址是否超出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ULIM&lt;/code&gt;），所以用户不可读写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;。这样就实现了对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组的保护。&lt;/p&gt;

&lt;p&gt;这个映射用&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPAGES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;来实现。&lt;/p&gt;

&lt;p&gt;然后要完成内核栈的映射。从[KSTACKTOP - PTSIZE, KSTACKTOP]这部分都属于内核栈， 但被分为两个部分，上面[KSTACKTOP-KSTKSIZE, KSTACKTOP]是真正的内核栈，与某些物理页框映射，而[KSTACKTOP - PTSIZE, KSTACKTOP-KSTKSIZE ]不与物理地址映射，只是用来防止内核栈向下增长的时候发生溢出，然后覆盖了Memory-mapped IO部分，称为保护页。如果内核栈溢出，它就会发现物理地址不存在，抛出错误。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;KERNBASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;----&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xf0000000&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;--+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;KSTACKTOP&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;CPU0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Kernel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-|&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;Invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKGAP&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;CPU1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Kernel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-|&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;Invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KSTKGAP&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;              &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;                   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;MMIOLIM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xefc00000&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;--+&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapped&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;O&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/--&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MMIOBASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;+------------------------------+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xef800000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;内核栈是内核可读写，但用户不可见的，这些页面的权限要被设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PTE_W&lt;/code&gt;。调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt;, 将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KSTACKTOP-KSTKIZE&lt;/code&gt;开始到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KSTACKTOP&lt;/code&gt;的虚拟地址映射到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bootstack&lt;/code&gt;的物理地址上，大小如上面结构所示，为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KSTKSIZE&lt;/code&gt;，但要注意使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROUNDUP&lt;/code&gt;与页面大小对齐：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KSTACKTOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bootstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将整一个[KERNBASE, 2^32）的整个内核地址空间映射到内存的[0, 2^32-KERNBASE)，权限是内核可修改但用户不可见。我们知道KERNBASE的虚拟地址是0xf0000000, 而整个虚拟空间的大小是2^32也就是4G，所以内核的大小总共是256MB=0X10000000，这已经是与页面大小对齐的。 内存将一直有256MB的空间被内核占用。调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt;实现如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERNBASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检验&quot;&gt;检验&lt;/h3&gt;

&lt;p&gt;重新编译，启动QEMU，所有的检查都已经通过，说明分页机制与内核的分配已经正确实现：&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;h3 id=&quot;分页机制建立和开启全过程&quot;&gt;分页机制建立和开启全过程：&lt;/h3&gt;

&lt;p&gt;完整地阅读&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;，&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mem_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;i386_detect_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
	&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UVPT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boot_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;npages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PageInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;page_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPAGES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KSTACKTOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ROUNDUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KSTKSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bootstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
	&lt;span class=&quot;n&quot;&gt;boot_map_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERNBASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTE_W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;lcr3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kern_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;cr0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;cr0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CR0_PE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_PG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_AM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_WP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_NE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_MP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;cr0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_TS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CR0_EM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lcr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;内核部分虚拟地址空间的初始化全过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;检测总共可用的物理内存大小，由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;basemem&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extmem&lt;/code&gt;构成，记录总页数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npages&lt;/code&gt;和低地址页数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npages_basemem&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要初始化内核虚拟地址，必须通过页表来映射，但一开始，页表还不存在，页表的虚拟地址也还没有映射。因此，首先要分配页表目录的虚拟地址。这个分配无法通过分页机制来完成，只能通过静态映射：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir = boot_alloc(PGSIZE)&lt;/code&gt;. 页目录分配好后，首先初始化为全0.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为用户进程在访问虚拟地址时，需要访问页表，因此我们需要在ULIM以下为用户准备一份页表的只读拷贝。然而，总共1024份页表的开销较大，其实只要能够访问到页目录，就可以通过页目录访问到页表。 而我们甚至不用真的在内存中存放两份页目录，只需要将拷贝的虚拟地址也指向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;的物理地址即可。 所以，我们在页目录上让&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UVPT&lt;/code&gt;条目指向页目录本身，并设置用户只读：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;&lt;/code&gt;, 结构如图：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://pdos.csail.mit.edu/6.828/2014/lec/vpt.png&quot; alt=&quot;img&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;这里CR3寄存器存放的是进程页目录的虚拟地址。&lt;/strong&gt;操作系统中有&lt;strong&gt;内核页表&lt;/strong&gt;和&lt;strong&gt;进程页表&lt;/strong&gt;两种页表，进程页表是每个进程独自有一份的，页目录的虚拟地址存放在cr3寄存器中，当进程切换时，会加载页目录虚拟地址到cr3寄存器。进程页表既包含了用户态，也包含了内核态的虚拟地址，内核态的虚拟地址是所有进程都一样的，就是&lt;strong&gt;内核页表的拷贝，它的虚拟地址就在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UVPT&lt;/code&gt;，大小为一个页面&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拷贝好内核页目录后，因为接下来涉及到管理物理内存，需要记录每个页框的信息，这些信息保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;数组中。同样，需要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt;将pages静态映射到一片虚拟地址。如果打印出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;的虚拟地址，可以看到他们的虚拟地址分别是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f0119000&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f0118000&lt;/code&gt;， 是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f0400000&lt;/code&gt;之内的，这两个数据结构已经在物理内存中了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;初始化为0，然后用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_init&lt;/code&gt;将已经分配出去的物理页框引用位置为1，并将空闲物理页框添加到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;链表中，接下来，内核就可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;两个数据结构管理物理页框。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;允许用户读取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;来知道内存的占用情况，但为了保护该数据结构，同样要在ULIM以下为它保留一份拷贝，这份拷贝在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPAGES&lt;/code&gt;到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UVPT&lt;/code&gt;之间，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt;来进行映射。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;boot 的时候， 已经为内核初始化了一个栈，栈顶的界限是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bootstack&lt;/code&gt;，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt;将虚拟地址的KSTACK部分映射到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bootstack&lt;/code&gt;所在的物理内存上，进程进入内核态，并进入公共部分时，实际上运行在这个内核栈上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，把整个高地址部分的内核虚拟空间映射到物理内存0地址开始处，实际上是内核部分一直驻留在内存中，且内核的虚拟地址空间被拷贝到每个进程的高地址部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lcr3(PADDR(kern_pgdir))&lt;/code&gt;是把内核页目录基址放在cr3寄存器中，之后如果开启分页，访问虚拟地址时，就会从cr3加载页目录地址，从而访问页目录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将控制寄存器cr0置位为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP ，~(CR0_TS|CR0_EM)&lt;/code&gt;各个字段含义如下：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define CR0_PE		0x00000001	// Protection Enable
#define CR0_MP		0x00000002	// Monitor coProcessor
#define CR0_EM		0x00000004	// Emulation
#define CR0_TS		0x00000008	// Task Switched
#define CR0_ET		0x00000010	// Extension Type
#define CR0_NE		0x00000020	// Numeric Errror
#define CR0_WP		0x00010000	// Write Protect
#define CR0_AM		0x00040000	// Alignment Mask
#define CR0_NW		0x20000000	// Not Writethrough
#define CR0_CD		0x40000000	// Cache Disable
#define CR0_PG		0x80000000	// Paging
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;cr0被设置为，开启保护模式，&lt;strong&gt;保护模式开启时只是开启了段级保护，没有开启分页，即逻辑地址转换成线性地址，线性地址直接等于物理地址&lt;/strong&gt;, CR0_PG开启分页，CR0_AM 开启地址对齐检查， 开启写保护， 开启协处理器错误， 开启监控协处理器。TS任务已切换标志为0，EM为0，表示有协处理器，会将浮点指令交给协处理器用软件来模拟。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何保护内核数据和代码&quot;&gt;如何保护内核数据和代码：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过虚拟地址空间的隔离。检查用户访问的虚拟地址与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ULIM&lt;/code&gt;，可以防止用户访问高地址。&lt;/li&gt;
  &lt;li&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ULIM&lt;/code&gt;以下的每个页面设置权限，并启用cr0中的非法写保护，可以防止无权限用户修改只读页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何管理内存空闲空间以及管理的开销&quot;&gt;如何管理内存空闲空间，以及管理的开销：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过一对一地维护每个页框的信息，并动态维护一个空闲页框链表（头指针）来实现。&lt;/li&gt;
  &lt;li&gt;每个页框PageInfo的大小是8B，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;的大小是PTSIZE=4MB, 总共可存放512K个PageInfo，即可维护512K个物理页，总共512K*PGSIZE=2G物理内存。&lt;/li&gt;
  &lt;li&gt;如果全部2G的物理内存都分配出去，那么维护的开销是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;大小+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;大小+所有页表页大小=4MB+4K+2MB的额外内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读： &lt;a href=&quot;http://localhost:4000/lab report/2020/01/31/OS4&quot;&gt;OS操作系统实验 xv6调度算法实现&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="Lab Report" /><category term="OS" /><category term="JOS" /><summary type="html">本文详解JOS操作系统虚拟内存的结构，以及内存管理单元的结构与实现。 在这次实验中，将探索以下问题： 计算机启动时如何开启虚拟内存 程序虚拟地址空间的结构 如何将内核物理地址与虚拟地址映射 访问一个虚拟地址的时候，会发生什么 如何管理内存空闲空间 如何保护特定的代码和数据 ……</summary></entry><entry><title type="html">OS操作系统实验：xv6调度(RR, 优先级调度, 优先级队列） 实现和分析 Part 2- xv6 RR调度情况统计</title><link href="http://localhost:4000/lab%20report/2020/01/31/OS4-2/" rel="alternate" type="text/html" title="OS操作系统实验：xv6调度(RR, 优先级调度, 优先级队列） 实现和分析 Part 2- xv6 RR调度情况统计" /><published>2020-01-31T00:00:00+08:00</published><updated>2020-01-31T00:00:00+08:00</updated><id>http://localhost:4000/lab%20report/2020/01/31/OS4-2</id><content type="html" xml:base="http://localhost:4000/lab%20report/2020/01/31/OS4-2/">&lt;p&gt;上一篇： &lt;a href=&quot;http://localhost:4000/lab report/2020/01/31/OS4/&quot;&gt;Part 1-xv6 调度代码讲解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;todo2-统计rr调度情况&quot;&gt;TODO2： 统计RR调度情况&lt;/h2&gt;

&lt;h3 id=&quot;实现waitsch系统调用&quot;&gt;实现waitSch系统调用&lt;/h3&gt;

&lt;p&gt;todo2需要增加一个系统调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch(int* rutime, int* retime, int* sltime)&lt;/code&gt;作为原来&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;的扩展，除了执行原有功能以外，要将进程的运行时间、在等待队列中的时间和休眠时间输入到三个参数所代表的地址中。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先我们将需要维护的数据结构定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc.h&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;// Size of process memory (bytes)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Page table&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Bottom of kernel stack for this process&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// 创建时间&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 处于RUNNING下的时间&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 处于ready状态下的时间&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 处于Sleeping状态下的时间&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc.c&lt;/code&gt;中，也应该做出相关的修改。首先在进程被初始化的时候，应该将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;ctime&lt;/code&gt;设置为当时的时钟ticks，然后其他的几个变量应该初始化为0。考虑到第一个用户进程并不是由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt;产生，我们将初始化放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allocproc&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;found:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EMBRYO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextpid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

														&lt;span class=&quot;c1&quot;&gt;//modified here&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//创建时间&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Allocate kernel stack.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//分配错误的时候，要恢复为0.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相应地，当进程结束，资源要被回收时，应该将这几个变量清空。我们不修改在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit&lt;/code&gt;中，因为此时这些进程运行的统计数据仍然要保留，直到父进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;找到它，将它回收的时候，再把这些数据处理完清空。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZOMBIE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Found one.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;freevm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        												&lt;span class=&quot;c1&quot;&gt;// modified&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        												&lt;span class=&quot;c1&quot;&gt;// end&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来是实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;的大部分逻辑都和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;一样，不同的只是要先把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;rutime&lt;/code&gt;赋给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*rutime&lt;/code&gt;，把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;retime&lt;/code&gt;赋给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*retime&lt;/code&gt;, 以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;sltime&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*sltime&lt;/code&gt;，然后再把这些变量清空:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;waitSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Scan through table looking for exited children.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZOMBIE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Found one.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;freevm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        																&lt;span class=&quot;c1&quot;&gt;// modified&lt;/span&gt;
	    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        																&lt;span class=&quot;c1&quot;&gt;// end&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// No point waiting if we don't have any children.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Wait for children to exit.  (See wakeup1 call in proc_exit.)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//DOC: wait-sleep&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在的问题是，如何动态地维护进程的运行时间、等待时间和休眠时间呢？&lt;/p&gt;

&lt;p&gt;首先一个直观的思路是，在每一次进程状态变化的时候，例如由A→B，记录下这次状态转换的时间作为B状态的开始时间$t_{0}$, 等下一次再从B→C的时候，B的持续时间就加上这个时刻减去$t_{0}$. 但是这种方法实现起来非常复杂，首先进程状态转换可能在很多种情况下发生，每一次转换时，都要判断旧的状态和新的状态是什么，然后更新旧状态的持续时间，保存新状态的开始时间。这样代码会变得冗长而且容易出错，还需要为进程维护两倍的变量（对每一种状态，例如RUNNING, 至少需要维护最近一次RUNNING状态开始的时刻，以及累计运行时间）。&lt;/p&gt;

&lt;p&gt;另一种思路是，在每一次收到时钟中断时，判断进程处于何种状态，为这种状态的持续时间加一。这样的计算是一种很粗糙的近似。这样计算，是假设进程会将这种状态维持一个时间片，在中间不发生状态的变换，并假设这种状态大概在时钟中断发生时开始。然而，在两个时钟中断之间，进程是很有可能调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;进行休眠的，也有可能在下一个时钟中断到来之前，调度器就已经调度了另一个进程并将该进程唤醒，状态变为RUNNABLE，这样，中间的sleep阶段就没有被我们的计算捕捉到。不过因为进程一般是运行和等待的时间占大多数，sleep占比很少，运行和等待之间的切换又一般是通过时钟中断引发的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;, 所以这种近似还是可以接受的。&lt;/p&gt;

&lt;h3 id=&quot;xv6-的时钟机制&quot;&gt;xv6 的时钟机制&lt;/h3&gt;

&lt;p&gt;xv6的时钟在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timer.c&lt;/code&gt;中实现，每过100ms，硬件就会产生一个时钟中断。每个cpu都可以独立地接收时钟中断，并陷入中断处理。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap.c&lt;/code&gt;中定义了一个uint类型的变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ticks&lt;/code&gt;，每一次这个变量加一，代表系统的时钟往前走了一步。两个cpu收到时钟中断后，先后进入中断处理程序，为了让系统的时钟(ticks)能够真正在每次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timer&lt;/code&gt;产生时钟中断的时候自增一，只在某一个固定的cpu收到中断时让&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ticks++&lt;/code&gt;, 因此xv6中每一次CPU0收到一个时钟中断，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ticks&lt;/code&gt;就自增1：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trapno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_IRQ0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRQ_TIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//收到了时钟中断&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//如果是cpu0收到了这个时钟中断，才将tick增加1；这样对于不同的cpu，时钟都是保持同步的，所有的cpu都会共用这个tick变量。&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tickslock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;       
      &lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tickslock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lapiceoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ashajh,time: %d, cpu: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译这段代码，输出是：
&lt;img src=&quot;/assets/images/report/oslab4-2-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这段输出中，每一次cpu id 为0时，对应的时钟比上一次printf增加一，而对于cpu1则不一定是这样。&lt;/p&gt;

&lt;p&gt;如果我们要在每次时钟中断时判断进程的状态，也有两种思路。&lt;/p&gt;

&lt;p&gt;第一个是，在时钟中断的时候，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;myproc&lt;/code&gt;先判断cpu上是否有进程在运行，如果有，则判断它的状态并更新变量。这种思路首先因为进程会在两个cpu上调度，而在cpu1上调度时，两次中断之间&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ticks&lt;/code&gt;不一定有增加，所以要增加一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lasttick&lt;/code&gt;保存上一次中断时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ticks&lt;/code&gt;的值，如果这个值有改变，才会进行判断。但即使是添加了这个逻辑，这种方法也是错误的，因为如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;myproc()&lt;/code&gt;能返回进程的PCB， 进程一定是处于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNING&lt;/code&gt;状态（否则它就不会被cpu调度了），这样我们无法知道进程何时在休眠或等待。&lt;/p&gt;

&lt;p&gt;第二个思路是，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ticks++&lt;/code&gt;的时候，遍历整一个ptable表，对每个进程判断它是在何种状态，然后给变量+1.这样便可实现上面那种近似的算法。 在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap.c&lt;/code&gt;中作以下修改：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trapno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_IRQ0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRQ_TIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tickslock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      									&lt;span class=&quot;c1&quot;&gt;//modified&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;                         &lt;span class=&quot;c1&quot;&gt;//每一次ticks++时，更新进程状态变量&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tickslock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lapiceoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，判断进程状态并更新变量的函数在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc.c&lt;/code&gt;中实现：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//对进程变量进行修改，要先获得ptable锁。&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//遍历整个表，判断进程状态&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//运行中&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//则运行时间增加一个时间片&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLEEPING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//休眠中&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//休眠时间增加一个时间片&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//等待中&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//等待时间增加一个时间片&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// default，有ZOMBIE\EMBRYO\UNUSED，这些状态我们不关心&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//释放锁&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们按照上次实验的步骤将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;包装成系统调用。 实现过程中比较重要的是，xv6&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall.c&lt;/code&gt;中系统调用函数的统一格式是返回值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;, 不允许带参数。如果需要加入参数，则参数会被压入栈中，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argint&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argptr&lt;/code&gt;从栈上取出参数进行解析。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysproc.c&lt;/code&gt;中包装&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sys_waitsch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//如果有子进程退出，打印出它的pid，运行时间、等待时间和休眠时间。&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pid: %d, runtime:%d, ready time: %d, sleep time %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall.h&lt;/code&gt;以及系统调用表中，为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;增加系统调用号，并在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user.h&lt;/code&gt;中定义接口。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;的实现已经完成。&lt;/p&gt;

&lt;h3 id=&quot;编写rrstac-统计rr调度情况&quot;&gt;编写RRsta.c 统计RR调度情况&lt;/h3&gt;

&lt;p&gt;编写RRsta.c， main函数接收一个命令行参数n, fork n个子进程进行相同的大规模计算，然后父进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;，等待每个子进程的结束，并输出每个子进程的运行时间、等待时间和休眠时间。最后统计n个进程在RR（Round Robin）调度下的平均轮转时间。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;param.h&quot;
#include &quot;types.h&quot;
#include &quot;stat.h&quot;
#include &quot;user.h&quot;
#include &quot;fs.h&quot;
#include &quot;fcntl.h&quot;
#include &quot;syscall.h&quot;
#include &quot;traps.h&quot;
#include &quot;memlayout.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//命令行参数，为fork 子进程的个数&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//在子进程内status=pid=0&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//执行相同的运算，主要是大规模乘、除法计算。&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//一定要注意exit，否则子进程也会执行上面的fork循环。&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//运行时间&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//子进程pid&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//周转时间总和&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitSch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;average turn-around time of %d process is %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RRsta.c&lt;/code&gt;编译到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qemu&lt;/code&gt;中，在shell中运行&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make clean
make
make qemu
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;RRsta 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab4-2-2.png&quot; alt=&quot;image-20191115012022441&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（实际上，手动计算平均周转时间的话会得到5.8， 但是xv6的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt;并没有使用C的标准输出库，不支持输出浮点数，只能将小数省去了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;下一篇： &lt;a href=&quot;http://localhost:4000/lab report/2020/01/31/OS4-3/&quot;&gt;Part 3： 优先级和动态多及反馈队列的实现、调度算法比较&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="Lab Report" /><category term="OS" /><category term="xv6" /><category term="scheduling" /><summary type="html">上一篇： Part 1-xv6 调度代码讲解 TODO2： 统计RR调度情况 实现waitSch系统调用 todo2需要增加一个系统调用waitSch(int* rutime, int* retime, int* sltime)作为原来wait的扩展，除了执行原有功能以外，要将进程的运行时间、在等待队列中的时间和休眠时间输入到三个参数所代表的地址中。</summary></entry><entry><title type="html">OS操作系统实验：xv6调度(RR, 优先级调度, 优先级队列） 实现和分析 Part 3- xv6 优先级调度算法实现</title><link href="http://localhost:4000/lab%20report/2020/01/31/OS4-3/" rel="alternate" type="text/html" title="OS操作系统实验：xv6调度(RR, 优先级调度, 优先级队列） 实现和分析 Part 3- xv6 优先级调度算法实现" /><published>2020-01-31T00:00:00+08:00</published><updated>2020-01-31T00:00:00+08:00</updated><id>http://localhost:4000/lab%20report/2020/01/31/OS4-3</id><content type="html" xml:base="http://localhost:4000/lab%20report/2020/01/31/OS4-3/">&lt;p&gt;上一篇： &lt;a href=&quot;http://localhost:4000/lab report/2020/01/31/OS4-2/&quot;&gt;Part 2 RR调度周转、等待时间等的统计&lt;/a&gt;
第一篇： &lt;a href=&quot;http://localhost:4000/lab report/2020/01/31/OS4/&quot;&gt;Part 1 xv6调度代码讲解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;todo3--实现优先级调度算法&quot;&gt;TODO3:  实现优先级调度算法&lt;/h2&gt;

&lt;p&gt;基于优先级的调度算法是一类算法，基本思想是为每一个进程赋予不同的优先级，在调度时优先选择优先级最高的进程来调度。优先级调度有许多种，大致可以分为：&lt;/p&gt;

&lt;!--more--&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;非抢占式的优先级调度：&lt;/p&gt;

    &lt;p&gt;非抢占式的优先级调度算法中，每个进程只在初始时赋予一个优先级，在运行过程中不会被改变。每一次重新调度时，选择最高优先级的一个进程，将它运行完毕，然后再选择另外一个进程开始运行。一个进程在运行过程中如果有更高优先级的进程到来，它不会被打断，只是将该进程放到等待队列的队首。&lt;/p&gt;

    &lt;p&gt;xv6是开启抢占的，进程会被时钟中断打断，然后调度器选择另外一个进程（如果有的话）来代替它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抢占式优先级调度：&lt;/p&gt;

    &lt;p&gt;抢占式优先级调度中，如果进程运行过程有更高优先级的进程到来，当它运行完这个时间片，就会被抢占。进程被赋予一个初始优先级，但这个优先级是可变的。具体的实现也有多种：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;静态优先级调度：&lt;/p&gt;

        &lt;p&gt;静态优先级调度指的是进程最初有一个优先级，运行过程中可以通过系统调用改变这个优先级，但是不会随着等待时间或运行时间的增加而自动改变。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;动态优先级调度：&lt;/p&gt;

        &lt;p&gt;进程最初被指定一个优先级，同样也可以通过系统调用改变。为了惩罚执行时间较长的进程，优先级会随着运行时间增加而逐渐降低。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;多级反馈队列调度：&lt;/p&gt;

        &lt;p&gt;在系统中设置每个优先级对应的等待队列，进程初始化时进入某个队列。调度时，首先从最高优先级队列中找进程，只有当更高优先级队列为空时，才会调度某个低优先级队列中的进程。 同一个优先级的进程按FCFS调度。&lt;/p&gt;

        &lt;p&gt;多级反馈队列也有不同的实现。静态实现时，进程优先级不在运行过程中自动改变；动态实现时，可以让进程每运行完k个时间片，就下降到低一级的等待队列，一段时间后，再将进程提高到最高优先级。这样，既可以充分考虑IO-bound、CPU-bound进程的不同特性，又考虑到进程运行过程中IO-bound到CPU-bound的动态转变，减少进程饥饿的发生。&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/report/oslab43-1.png&quot; alt=&quot;image-20191115165057350&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我将实现静态优先级调度和静态的多级反馈队列调度。&lt;/p&gt;

&lt;h3 id=&quot;静态优先级调度&quot;&gt;静态优先级调度&lt;/h3&gt;

&lt;p&gt;静态优先级调度是为每个进程赋予一个初始优先级，用户可以指定优先级。在每次重新调度时，遍历整个进程表，找到状态为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNABLE&lt;/code&gt;且优先级最高的进程来运行。&lt;/p&gt;

&lt;p&gt;优先级的范围是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1,4]&lt;/code&gt;, 数字越低代表优先级越高。&lt;/p&gt;

&lt;p&gt;首先为进程添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;priority&lt;/code&gt;变量：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Per-process state&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;// Size of process memory (bytes)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Page table&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Bottom of kernel stack for this process&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.....&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// 进程的优先级, 取值范围是1-4&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// 创建时间&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;优先级调度的一个问题是，如何决定进程初始化时的优先级。初始化时的优先级也是系统进程的优先级，这个优先级不能太高，否则会让用户进程响应和等待的时间过长；但也不能太低，否则当用户需要某个内核进程的服务时，等待时间也会太长。这里，先将初始优先级设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;. 在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allocproc()&lt;/code&gt;中，进程初始化时：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;found:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EMBRYO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextpid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

														&lt;span class=&quot;c1&quot;&gt;//modified here&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

														&lt;span class=&quot;c1&quot;&gt;//priority modified&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;新的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;函数，在内层for循环中，再遍历整个进程表，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phigh&lt;/code&gt;保存目前为止优先级最高的进程。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Enable interrupts on this processor.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sti&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Loop over process table looking for process to run.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

														&lt;span class=&quot;c1&quot;&gt;//PRIORITY modified&lt;/span&gt;


    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

      &lt;span class=&quot;cp&quot;&gt;#if defined RR
&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// 原来的 Round Robin 调度&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;cp&quot;&gt;#elif defined PRIORITY             // 静态优先级调度
&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;// 用来遍历ptable的指针&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// 遍历过程中保存最高优先级的进程&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      
      &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// 遍历整个表之前，phigh首先是下一个RUNNABLE的进程。&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 遍历表中所有RUNNABLE的进程&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//如果有一个RUNNABLE的进程优先级比phigh高&lt;/span&gt;
	      &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;							&lt;span class=&quot;c1&quot;&gt;//更新phigh&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;//令下一个执行的进程为phigh&lt;/span&gt;
      &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;      

      &lt;span class=&quot;c1&quot;&gt;// Switch to chosen process.  It is the process's job&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// to release ptable.lock and then reacquire it&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// before jumping back to us.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d is being scheduled on cpu: %d, its priority is %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apicid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	 	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;switchuvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	 	&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	 	&lt;span class=&quot;n&quot;&gt;swtch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;switchkvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	 &lt;span class=&quot;c1&quot;&gt;// Process is done running for now.&lt;/span&gt;
	 &lt;span class=&quot;c1&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;
	 	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调度器的内层循环用指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;遍历整个进程表，本来每一次找到一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNABLE&lt;/code&gt;进程，就切换到该进程。 用priority算法，每次调度一个进程后返回调度器时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;指向下一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNABLE&lt;/code&gt;进程，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phigh&lt;/code&gt;首先指向这个进程，然后遍历整个进程表，如果有更高级的进程，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phigh&lt;/code&gt;会指向接下来第一个优先级最高的进程；如果没有，则下一个进程就是表中下一个可执行进程。&lt;/p&gt;

&lt;p&gt;实现系统调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_priority&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set_priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

           &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;          
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 找不到该pid，错误&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;把它封装好之后，修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RRsta.c&lt;/code&gt;， 加入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_priority&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;usage: priority_sta &amp;lt;fork number&amp;gt; &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    	&lt;span class=&quot;n&quot;&gt;set_priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//在父进程中，将每个子进程的优先级设置为i%4+1.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	    	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		    	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
					&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
					&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			    		&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
					&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		   		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitSch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; average turn-around time of %d process is %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forknumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在内核中，添加一些额外的输出来验证算法实现的正确性。重新编译内核，然后执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;priority_sta.c&lt;/code&gt;, fork 4个进程：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;priority_sta 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab43-3.png&quot; alt=&quot;image-20191115172428255&quot; /&gt;&lt;/p&gt;

&lt;p&gt;pid为3的进程是父进程，子进程的pid分别为4， 5， 6， 7，创建后set_priority, 使它们的优先级分别为1， 2， 3， 4；进程的初始优先级被设置为2.&lt;/p&gt;

&lt;p&gt;当进程4被创建，并设置优先级为1之后，它是系统中优先级最高的进程，正确情况下会一直运行直到结束（除非它进入休眠，或者有同样优先级为1的进程到来）；因为有两个cpu，进程3可以在另一个cpu上调度，继续创建进程5，6. 这时，进程4已经结束，系统中有3，5， 6三个进程，但正确情况下只有3和5可以被调度，6必须等待直到3和5不是RUNNING或RUNNABLE状态。&lt;/p&gt;

&lt;p&gt;从这段程序的输出来看，目前的调度都是正确的。进程6一直没有被调度，直到进程3进入休眠：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab43-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程3创建了进程7（最后一个子进程）之后，它就进入休眠等待所有子进程结束。这时进程6被第一次调度，而直到进程5结束，系统只剩下3，6，7时，在进程3休眠时进程7才可被调度。&lt;/p&gt;

&lt;p&gt;统计所有进程的运行情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab43-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优先级越高的进程平均周转时间越长。从图中可以看出，进程的运行时间相差不大，而优先级最低的进程（7，11）明显等待时间比其他进程要长很多（11）。但从单个进程来看，不一定优先级越低进程周转时间越长，例如进程10（优先级为3）的周转时间就比进程11（优先级为4）长很多，这是因为进程11到达更晚，且它到达时系统中更高优先级的进程几乎已经都执行结束。&lt;/p&gt;

&lt;h3 id=&quot;静态多级反馈队列&quot;&gt;静态多级反馈队列&lt;/h3&gt;

&lt;p&gt;静态多级反馈其实跟上面的静态优先级调度类似，但是它使用了多级队列的方法，使优先级相同的进程能够按照FCFS来调度。静态优先级调度则不一定是先来先服务的，因为它是遍历整个进程表找最高优先级的进程，这样，当pid序号在前的进程退出被回收之后，前面就会出现空槽，更新创建的进程反而会比老的进程pid序号更低，更先被调度。&lt;/p&gt;

&lt;p&gt;实现多级反馈队列，首先要为每个优先级定义对应的等待队列。等待队列由一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc&lt;/code&gt;结构体的指针数组来表示，考虑到进队和出队的动作一般发生在进程的优先级发生改变或者状态改变的时候，都会持有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;,则访问等待队列已经可以保证互斥。因此可以省略等待队列的锁。同时，用变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size&lt;/code&gt;来表示等待队列目前的大小，也就是最后一个进程的下标。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#if defined SML
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//for debug&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//4个优先级队列&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;内核开始时，要初始化4条优先级队列，定义一个初始化函数来完成：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;pqueue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//为方便输出debug，加入变量priority&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//初始时指针为0&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;pinit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;initlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ptable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
				
  &lt;span class=&quot;cp&quot;&gt;#if defined SML									//sml modified
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;pqueue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pqueue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pqueue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pqueue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等待队列涉及三种操作，即入队，删除队列中的一个进程，以及取等待队列中最早到达的一个RUNNABLE的进程。&lt;/p&gt;

&lt;p&gt;由于进程的优先级在运行过程中可能动态变化，所以可能要将一个进程从某个队列删除后添加到另一个队列中，这时，为了保持队列从到达时间早到晚排序，要遍历队列，找到该进程的插入位置。从最后（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q-&amp;gt;size-1&lt;/code&gt;)往前扫描，如果当前指针进程的到达时间&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctime&lt;/code&gt;比新进程&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;ctime&lt;/code&gt;大（晚），就把它往后挪。直到指向一个进程，到达时间&amp;lt;=&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;ctime&lt;/code&gt;，然后把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;插入到它的后面。最后，要将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q-&amp;gt;size&lt;/code&gt;增加一。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;proc %d enqueueing %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//从后往前扫描&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//如果目前进程比新插入进程到达晚，就把它向后挪一个位置&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 目前pos指向的进程比插入的进程到达时间早或相同。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   
    &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;删除队列的操作，是从前往后遍历该等待队列，找到要删除的进程，如果能找到，则将从该位置开始后面的进程都往前挪一个位置，最后一个位置变为0，最后把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size&lt;/code&gt;减1.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;removing %d from q: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//从前往后，找到该进程&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//若找到，此时pos指向要删除的进程&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//从 pos 到倒数第二个进程位置&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//将所有进程往前挪一个位置&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查找等待队列中第一个RUNNABLE的进程，只要从前往后遍历，找到第一个RUNNABLE的进程就返回即可。如果未找到，则返回0.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;headq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//找到第一个RUNNABLE进程，注意等待队列是从到达时间小到大排序的&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来要就是要实现进程在执行过程中状态或优先级变化时相应的等待队列的操作。由于等待队列代价比较高，所以尽量在确定进程已经正确分配好各种资源，才将它加入到初始优先级队列中去。 在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;userinit&lt;/code&gt;中，设置默认优先级为2：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#if defined SML														//sml modified
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;中，让子进程继承父进程的优先级（默认为2），然后进入相应的等待队列：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyuvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;									
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
														&lt;span class=&quot;c1&quot;&gt;//sml modified&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cp&quot;&gt;#if defined SML
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//进入相应的优先级队列&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;priority must be between 1-4.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     
  &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在进程终止，被父进程回收资源时，要将它们从相应的等待队列中删除，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitSch&lt;/code&gt;中作同样的改变：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Scan through table looking for exited children.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZOMBIE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Found one.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;freevm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
          												&lt;span class=&quot;c1&quot;&gt;//SML modified&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#if defined SML
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;//删除等待队列中的进程&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	     	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	     	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	     	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	     	&lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;	
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        												&lt;span class=&quot;c1&quot;&gt;// modified&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rutime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sltime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        												&lt;span class=&quot;c1&quot;&gt;// end&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调度器的算法则跟之前较为不同。RR和静态优先级调度&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;都是内循环遍历整个表，每次寻找最高优先级或第一个RUNNABLE进程进行调度，现在，静态多级反馈队列不用遍历整个表，它从最高优先级队列开始找起，如果某个队列里面有RUNNABLE的进程，就运行它，否则就往下一个优先级队列继续寻找：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;cp&quot;&gt;#if defined RR ||PRIORITY
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

      &lt;span class=&quot;cp&quot;&gt;#if defined RR
&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;cp&quot;&gt;#elif defined PRIORITY
&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      
      &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	  &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phigh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;  
      

      &lt;span class=&quot;c1&quot;&gt;// Switch to chosen process.  It is the process's job&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// to release ptable.lock and then reacquire it&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// before jumping back to us.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d is being scheduled on cpu: %d, its priority is %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apicid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	 &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;switchuvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	 &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	 &lt;span class=&quot;n&quot;&gt;swtch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;switchkvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	 &lt;span class=&quot;c1&quot;&gt;// Process is done running for now.&lt;/span&gt;
	 &lt;span class=&quot;c1&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;
	 &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;                                      &lt;span class=&quot;c1&quot;&gt;//=====================modified begin ================//&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#if defined SML                            //多级反馈队列从这里开始
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;                          &lt;span class=&quot;c1&quot;&gt;//若找得到进程，则运行它，否则暂时释放ptable锁，开启中断，然后再次获取ptable锁，继续从第一优先级队列开始寻找&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;cprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d is being scheduled on cpu: %d, its priority is %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apicid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;switchuvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	     &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	     &lt;span class=&quot;n&quot;&gt;swtch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;switchkvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	 &lt;span class=&quot;c1&quot;&gt;// Process is done running for now.&lt;/span&gt;
	 &lt;span class=&quot;c1&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;
	     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#endif  
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_priority&lt;/code&gt;时，有可能进程的优先级改变，则要将它从旧的优先级队列中删除并放到新的优先级队列中：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set_priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
       
           &lt;span class=&quot;cp&quot;&gt;#if defined SML
&lt;/span&gt;           &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
           	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
           	    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
           	    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
           	    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
           	    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
           	    &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
           	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
           	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		       &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		       &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		       &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		       &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pqueue_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		       &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
           &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;           
           
           &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
           &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;          
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多级反馈队列实现已经完成。将它编译，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;priority_sta.c&lt;/code&gt;，还是将子进程数目设置为4，得到如下输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab43-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程3是父进程，4，5，6，7分别是4个子进程，优先级被设置为1，2，3，4. 可以看到，每个进程在fork完成之前，都先进入了默认的第二优先级队列。当调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_priority&lt;/code&gt;时，每个进程都从原来的queue 2离开，进入到相应新的队列中（进程5除外，进程5本来就在queue 2中）。当所有进程都创建好之后，因为3比5先到达，则只有进程3和4可以被调度；当进程3在倒数第二行进入休眠之后，进程5才可以得到调度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab43-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，等进程4退出并被回收了，它从queue 1中被删除。当进程3进入休眠的时候，进程5和6可以得到调度，在这整个过程中，进程7的优先级都不足，无法被调度。而当进程6进入休眠时，进程7才和5一起被调度。说明算法逻辑正确。&lt;/p&gt;

&lt;p&gt;统计多级反馈下程序运行时间：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/report/oslab43-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个结果是符合预期的，如果程序执行的内容都一样，优先级越低，周转时间应该越长，因为更高优先级的进程应该更早被调度。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;简单比较&quot;&gt;简单比较&lt;/h2&gt;

&lt;p&gt;比较所有进程的平均轮转时间：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;进程个数&lt;/th&gt;
      &lt;th&gt;RR&lt;/th&gt;
      &lt;th&gt;静态优先级&lt;/th&gt;
      &lt;th&gt;多级反馈队列&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;（轮转时间的计算跟机器状态也有关系，有些时候机器运转较快，则用户程序的运行和调度算法都比较快，测得时间就会少）&lt;/p&gt;

&lt;p&gt;如果忽略机器状况的因素，可以发现RR算法的平均轮转时间在进程个数一定时是多于静态优先级调度的。这是因为所有进程轮流调度，本来可以更早结束的进程时间被延长了；而静态优先级调度虽然低优先级的进程周转时间比平均长很多，但优先级高的进程周转时间也对应地低很多，并且如果先来先服务，高优先级进程基本上可以到达之后就一直进行直到结束，所以平均周转时间可能会更好。&lt;/p&gt;

&lt;p&gt;但也要考虑算法的花销。在进程个数很多的时候，多级反馈队列每一次插入和删除的开销会快速增长，这导致进程的等待时间变得非常长。&lt;/p&gt;

&lt;p&gt;为了缓解饥饿的问题，可以对优先级调度算法进行优化，采用动态的多级反馈队列：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进程刚开始时进入最高优先级队列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;不同的优先级队列中，进程有不同的时间片。优先级越高，时间片越短。这样，低优先级进程可以有更多机会完成任务。&lt;/li&gt;
  &lt;li&gt;每运行完一个/k个时间片，进程就下降优先级，最低优先级的进程反而重新回到最高优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做的好处是，进程刚开始创建优先级最高，可以有更快的响应时间；优先级随着进程运行下降，则可以偏向短作业，让短作业更快结束，从而缩短等待时间；每隔一段时间就将最低优先级的进程提高到高优先级，这样可以防止饥饿发生。&lt;/p&gt;

&lt;p&gt;但是，动态多级反馈队列显然需要更多的算法花销，不同时间片的设计更为复杂，且需要设计每个优先级适当的时间片大小，以及按进程特性决定创建时进入哪个队列。即便如此，动态多级反馈队列仍然是一种比较优的算法。&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="Lab Report" /><category term="OS" /><category term="xv6" /><category term="scheduling" /><summary type="html">上一篇： Part 2 RR调度周转、等待时间等的统计 第一篇： Part 1 xv6调度代码讲解 TODO3: 实现优先级调度算法 基于优先级的调度算法是一类算法，基本思想是为每一个进程赋予不同的优先级，在调度时优先选择优先级最高的进程来调度。优先级调度有许多种，大致可以分为：</summary></entry><entry><title type="html">OS操作系统实验：xv6调度(RR, 优先级调度, 优先级队列） 实现和分析 Part 1- xv6代码讲解</title><link href="http://localhost:4000/lab%20report/2020/01/31/OS4/" rel="alternate" type="text/html" title="OS操作系统实验：xv6调度(RR, 优先级调度, 优先级队列） 实现和分析 Part 1- xv6代码讲解" /><published>2020-01-31T00:00:00+08:00</published><updated>2020-01-31T00:00:00+08:00</updated><id>http://localhost:4000/lab%20report/2020/01/31/OS4</id><content type="html" xml:base="http://localhost:4000/lab%20report/2020/01/31/OS4/">&lt;h1 id=&quot;lab-4调度&quot;&gt;Lab 4：调度&lt;/h1&gt;

&lt;h2 id=&quot;调度&quot;&gt;调度&lt;/h2&gt;

&lt;p&gt;任何操作系统中，都可能出现进程的个数大于处理器个数的情况，这就需要考虑如何分配处理器资源。一般进程的执行是CPU计算和IO操作的循环，当进程长时间等待某种资源时，为了更好地利用CPU资源，应选择其他准备好的进程来代替它；当进程完成所需的时间过长时，为了让其他已经在系统中的进程等待时间不要过长，也需要在某个适当的时间暂停当前的进程, 因此便需要多进程并发，也就需要调度。&lt;/p&gt;

&lt;p&gt;调度指的是决定一个进程在什么时候、是否要暂停，从一个等待队列中选择另一个进程来代替它，调度涉及调度策略的选择，也包含完成进程切换的动作。操作系统通过不断地调度，造成并发的效果，同时也为每个进程造成独占资源的假象。调度涉及以下的问题：&lt;/p&gt;

&lt;!--more--&gt;

&lt;ol&gt;
  &lt;li&gt;如何进行进程的切换？这是通过上下文的切换来实现的。上下文是一个进程运行状态的描述，包括程序计数器(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%eip&lt;/code&gt;), 栈底指针(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%ebp&lt;/code&gt;), 以及其他一些寄存器的值。在进程切换时，首先要保存旧进程的上下文在内核栈上，选择一个新进程，从该进程的内核栈上加载它的上下文，然后CPU就开始执行新进程&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%eip&lt;/code&gt;指向的指令。上下文的保存和加载使得程序可以从上次调度被暂停的地方接着进行，对进程来说，就好像切换从来没有发生过一样。&lt;/li&gt;
  &lt;li&gt;如果进程不是调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;主动放弃CPU，如何让进程的切换透明化呢？ xv6简单地使用时钟中断来完成。当时钟中断到来时，进程陷入中断处理程序，在内核中调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;来进行上下文切换。&lt;/li&gt;
  &lt;li&gt;多个CPU同时在切换进程时，由于需要对进程表进行修改，可能会产生竞态条件，因此还要用锁来避免竞争。&lt;/li&gt;
  &lt;li&gt;进程结束时，需要释放资源。进程不能自己释放自己的所有资源，因此内核中还必须有一个角色负责监测进程的结束、释放资源。&lt;/li&gt;
  &lt;li&gt;当进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;进入睡眠时，调度也会发生。这时，要确保有其他进程可以唤起该进程，因此xv6需要提供一套进程间通信的机制，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wake up&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本次实验将详细研究整个调度的过程，看xv6如何解决上述问题，并实现优先级调度算法。&lt;/p&gt;

&lt;p&gt;在开始实验之前，需要了解以下事实： xv6永远不会从一个用户态进程切换到另一个用户态进程。在xv6中，调度发生在以下几种情况：1. 进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;进入休眠，主动放弃CPU，这会导致进程进入内核态，保存进程的上下文并加载调度器的上下文，当调度器返回时，该进程仍处于内核态；2. 进程收到时钟中断，已经运行完一个时间片，这也会导致进程进入内核态，并在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;中将控制权交给调度器；3. 进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit&lt;/code&gt;结束。 在这些情况下，切换的过程都是 陷入内核→保存上下文→切换到调度器的上下文 → 切换到新进程的上下文（在内核态中） → 返回新进程的用户态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://th0ar.gitbooks.io/xv6-chinese/content/pic/f5-1.png&quot; alt=&quot;figure5-1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;todo1-阅读procc中的函数&quot;&gt;TODO1: 阅读proc.c中的函数&lt;/h2&gt;

&lt;p&gt;我们先看调度发生的一般场景：进程运行完时间片，被迫放弃CPU，选择下一个进程调度。&lt;/p&gt;

&lt;p&gt;xv6的时钟每100毫秒就产生一个中断，以此实现进程时间分片。时钟中断是由lapic产生的，因此每个cpu可以独立地接收它的时钟中断。当接收到时钟中断时，进程会开启保护模式，陷入到内核态，来到中断处理程序的入口，然后在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alltraps&lt;/code&gt;中保存中断帧，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traps&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traps&lt;/code&gt;根据中断号来判断应该执行哪种程序。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traps&lt;/code&gt;的最后，有可能调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;使进程放弃CPU：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// Force process to give up CPU on clock tick.&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// If interrupts were on while locks held, would need to check nlock.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trapno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_IRQ0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IRQ_TIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//当目前CPU上有正在运行的进程，且中断为时钟中断时，才会调用yield&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;yield&quot;&gt;yield&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;函数在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc.c&lt;/code&gt;中实现:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Give up the CPU for one scheduling round.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//DOC: yieldlock&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;是将目前进程的状态从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNING&lt;/code&gt;改为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNABLE&lt;/code&gt;，让进程进入等待队列，然后调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;将控制权转移给调度器。由于进程PCB存放在进程表上，因此对状态进行修改之前要首先&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire(&amp;amp;ptable.lock)&lt;/code&gt;获取进程表的锁，等进程再次被调度时，它会返回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;的下一行，释放进程表锁。这里要注意，在上一个实验中，我们知道xv6的内核中临界节内不允许中断，所以在进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;之前，中断是已经关闭的状态。&lt;/p&gt;

&lt;h3 id=&quot;sched&quot;&gt;sched&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;的任务是首先确保进程有放弃CPU，进行调度的条件，然后调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;进行上下文切换，转到cpu调度器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;上。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Enter scheduler.  Must hold only ptable.lock&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// and have changed proc-&amp;gt;state. Saves and restores&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// intena because intena is a property of this&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// kernel thread, not this CPU. It should&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// be proc-&amp;gt;intena and proc-&amp;gt;ncli, but that would&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// break in the few places where a lock is held but&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// there's no process.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;holding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sched ptable.lock&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mycpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ncli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sched locks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sched running&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readeflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FL_IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sched interruptible&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;intena&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;swtch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mycpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intena&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;holding(&amp;amp;ptable.lock)&lt;/code&gt;判断该cpu是否已经持有了进程表的锁，因为多个CPU在调度过程中都需要访问进程表，假如这个cpu进入调度之前，没有先持有锁，那就有可能使其他cpu也同时进行调度，同时访问进程表，可能会出现两个cpu选择了同一个进程调度的情况。&lt;/p&gt;

&lt;p&gt;然后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mycpu()-&amp;gt;ncli!=1&lt;/code&gt;判断该cpu调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pushcli&lt;/code&gt;的次数是否恰好为1，否则会报错。在上个实验我们知道，每一次调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt;获得锁，就会使&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ncli&lt;/code&gt;加一，释放锁后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ncli&lt;/code&gt;减一。所以ncli为1就说明这里只允许进程持有一个锁，也就是说，进程被切换时，必须持有进程表的锁，并且必须释放其他所有的锁。持有进程表的锁是为了保证CPU的调度是互斥的，防止竞态条件，而释放其他所有锁是为了防止死锁的情况出现。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p-&amp;gt;state==RUNNING&lt;/code&gt;，进程的状态是仍在运行，不可以进入调度。这是操作系统中约定好的分工：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;应该只负责进入调度器，而不应该判断进程是因为什么原因而被暂停的，所以假如进程是终止了，应该由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit&lt;/code&gt;来将状态变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZOMBIE&lt;/code&gt;，如果进程是被时钟中断了，应该由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;将状态变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNABLE&lt;/code&gt;，休眠也同理。进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;之前，进程的状态应该已经改变好。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;最后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readeflags()FL_IF&lt;/code&gt;，检查标志寄存器中IF段的值，确保中断已经关闭，然后它将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mycpu()-&amp;gt;intena&lt;/code&gt;暂时保存起来，这个变量表示CPU在调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;之前，中断是否被允许，因为之后在调度器中要调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sti&lt;/code&gt;开启中断，可能会破坏原来CPU的中断状态，所以暂存起来，等从调度器返回（进程被重新调度）的时候，再恢复这个值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch(&amp;amp;p-&amp;gt;context, mycpu()-&amp;gt;scheduler)&lt;/code&gt;来切换上下文，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;的汇编代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;# Context switch
#
#   void swtch(struct context **old, struct context *new);
# 
# Save the current registers on the stack, creating
# a struct context, and save its address in *old.
# Switch stacks to new and pop previously-saved registers.

.globl swtch
swtch:
  movl 4(%esp), %eax
  movl 8(%esp), %edx              # swtch的第二个参数，即新的上下文

  # Save old callee-saved registers
  pushl %ebp                      # 保存旧进程内核栈的栈底指针
  pushl %ebx                      # 保存旧进程%ebx寄存器
  pushl %esi					# 保存旧进程%esi
  pushl %edi					#               和%edi寄存器

  # Switch stacks
  movl %esp, (%eax)
  movl %edx, %esp				# 

  # Load new callee-saved registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，进程上下文中包含的信息有：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么只需要保存这些呢？假设进程在某个函数中，发生了上下文切换，那么首先不需要保存的是调用者保存的寄存器，如%eax，%ecx，%edx，因为该函数的调用者已经提前把它们保存在进程的栈上了。也不需要保存段寄存器，如%cs等，因为在指令地址发生改变的时候，这些寄存器也会同时改变。所以，要保存的有栈底指针、%ebx、程序计数器%eip、参数寄存器%edi、%esi。&lt;/p&gt;

&lt;p&gt;上下文保存在进程内核栈上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://th0ar.gitbooks.io/xv6-chinese/content/pic/f1-3.png&quot; alt=&quot;figure1-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在进程从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;进入到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;再进入到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;的这个时候，cpu首先是运行在旧进程的内核栈上的。在这里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;传入两个参数，第一个是旧进程上下文的指针的地址，第二个是该cpu调度器进程的上下文的指针，调度器的上下文也是调度器上一次调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;时保存的。我们逐条指令分析上下文切换的过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;swtch:
  movl 4(%esp), %eax                  # 第一个参数
  movl 8(%esp), %edx                  # 第二个参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两条指令中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%esp&lt;/code&gt;指向旧进程内核栈现在的栈底，因为它调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;，所以（%esp）上存放的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;的返回地址。4(%esp)和8(%esp)分别是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;的第一个和第二个参数，也就是旧进程上下文和新进程（调度器）上下文的指针。&lt;/p&gt;

&lt;p&gt;画出旧进程内核栈：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;…&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;旧进程上下文指针&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;p-&amp;gt;context&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;调度器上下文指针&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mycpu()-&amp;gt;scheduler&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;%esp→&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mycpu()-&amp;gt;intena = intena 对应指令的地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;# Save old callee-saved registers
  pushl %ebp                      # 保存旧进程内核栈的栈底指针
  pushl %ebx                      # 保存旧进程%ebx寄存器
  pushl %esi					# 保存旧进程%esi
  pushl %edi					#               和%edi寄存器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这四条指令是将旧进程的上下文保存到当前栈（旧进程的内核栈）上。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;…&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;旧进程上下文指针&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;amp;p-&amp;gt;context&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;调度器上下文指针&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mycpu()-&amp;gt;scheduler&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mycpu()-&amp;gt;intena = intena 对应指令的地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ebp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ebx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;esi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;%esp→&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;edi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;# Switch stacks
  movl %esp, (%eax)       # 令p-&amp;gt;context = %esp
  movl %edx, %esp				
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后交换栈。从第一、二条指令我们知道，现在（%eax）中是旧进程的上下文指针，令（%eax）=%esp，也就是让旧进程上下文指针重新指到现在它保存的地方。而%edx中是调度器上下文指针，把%edx赋给%esp，使栈底指针指向了调度器上下文所在的位置，这样，就&lt;strong&gt;从旧进程的内核栈切换到了调度器所在的栈&lt;/strong&gt;（前者是代表用户进程的，是用户进程在内核态下运行时使用的栈，后者不代表任何用户进程，它是内核进程进行时使用的栈）。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;(旧进程的内核栈)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;…&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;旧进程上下文指针&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;amp;p-&amp;gt;context&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;调度器上下文指针&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mycpu()-&amp;gt;scheduler&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;旧进程中swtch返回地址&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mycpu()-&amp;gt;intena = intena 对应指令的地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ebp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ebx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;esi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;strong&gt;p-&amp;gt;context&lt;/strong&gt;→&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;edi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;（调度器所在的栈）&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;…&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;调度器中swtch返回地址&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ret&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;调度器的上下文&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ebp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ebx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;esi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;strong&gt;%esp&lt;/strong&gt;→&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;edi&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;栈切换之后，栈底指针指向调度器上下文所在的地址。现在，就可以从栈上pop出调度器的上下文了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;# Load new callee-saved registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt;会返回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;的下一行位置（而不是返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;)。这样，cpu控制权就从旧的进程转移到了调度器。从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;指令中，我们没有看到对%eip的显式保存，这是因为旧进程的%eip在用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call swtch&lt;/code&gt;调用swtch时就已经隐式地保存在了%ebp的前面，同样，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt;指令也隐式地把调度器栈上的返回地址加载到了%eip中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;scheduler&quot;&gt;scheduler&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;就是上述的调度器。每一个进程最终都会将控制权返回到调度器，调度器会从等待队列中选择一个进程开始运行，它会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;保存自己的上下文，然后切换到该进程的上下文开始运行。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//PAGEBREAK: 42&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Per-CPU process scheduler.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Each CPU calls scheduler() after setting itself up.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Scheduler never returns.  It loops, doing:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  - choose a process to run&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  - swtch to start running that process&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  - eventually that process transfers control&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//      via swtch back to the scheduler.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Enable interrupts on this processor.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sti&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//每一次从sched进入调度器，都会开启中断&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Loop over process table looking for process to run.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// Switch to chosen process.  It is the process's job&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;........&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调度器是一个两层的for循环。外层循环是无限循环，这意味着调度器永远不会返回。内层循环中，调度器遍历进程表，选择进程运行。在CPU开始的时候，它就会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;每一次从内层循环退出，进入外层循环，都要显示地执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sti&lt;/code&gt;指令允许中断，并且要将ptable锁释放之后再重新获取。这两个步骤都是很有必要的，因为从内层循环退出，意味着调度器可能检查了一遍ptable，没有找到可以运行的进程，这时有可能所有的进程都在等待IO中断，如果不执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sti&lt;/code&gt;开启中断的话，IO中断永远也不能到达进程。而如果一个闲置CPU的调度器一直不释放锁，那么其他CPU也不能访问ptable，进行上下文或者系统调用了，所以就没有CPU能够将一个进程的状态改为RUNNABLE，这个CPU也无法跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;内层循环遍历进程表，寻找下一个RUNNABLE的进程并切换到进程的上下文中运行。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// Switch to chosen process.  It is the process's job&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// to release ptable.lock and then reacquire it&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// before jumping back to us.&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 找到了一个RUNNABLE的进程&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//该cpu上现在运行的进程为*p&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;switchuvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 加载该进程的地址空间&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//将进程状态变为RUNNING&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;swtch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;switchkvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// Process is done running for now.&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当调度器找到了一个RUNNABLE的进程，就将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpu-&amp;gt;proc&lt;/code&gt; 设置为它的PCB指针，然后调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;switchuvm&lt;/code&gt;将该进程的内存空间、页表加载进内存中，并将进程状态设置为RUNNING.&lt;/p&gt;

&lt;p&gt;然后，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;进行上下文的切换。现在，第一个参数（旧的上下文）是调度器的上下文指针的地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;(c-&amp;gt;scheduler)&lt;/code&gt;, 第二个参数是新进程上下文的指针。这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;将保存调度器的上下文，并将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c-&amp;gt;scheduler&lt;/code&gt;指向保存的位置，然后从调度器的栈换到新进程的内核栈，从栈上加载新进程的上下文，然后转到新进程&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;返回处运行。新进程将马上释放ptable 锁。&lt;/p&gt;

&lt;p&gt;有的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;也不一定是返回到新进程的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;处。如果该新进程是刚刚被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt;产生，这是它第一次被调度，那么&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;就会返回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forkret&lt;/code&gt;处，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forkret&lt;/code&gt;中释放ptable锁，再从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forkret&lt;/code&gt;返回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trapret&lt;/code&gt;，退出内核态。&lt;/p&gt;

&lt;p&gt;当调度器从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtch&lt;/code&gt;返回，意味着有某个进程调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;把控制权返还给它，它首先调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swtchkvm&lt;/code&gt;转换到内核的页表，然后将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c-&amp;gt;proc&lt;/code&gt;置为0，表示暂时没有进程在该cpu上运行。然后，如果该进程不是位于ptable的最后一个槽，调度器就会继续查找下一个RUNNABLE的进程，重复以上步骤。否则，它将释放ptable锁，并开启中断。&lt;/p&gt;

&lt;h3 id=&quot;睡眠与唤醒&quot;&gt;睡眠与唤醒&lt;/h3&gt;

&lt;p&gt;睡眠和唤醒提供了进程间通信的机制，它们可以让一个进程暂时休眠，等待某个特定事件的发生，然后当特定事件发生时，另一个进程会唤醒该进程。睡眠与唤醒通常被称为顺序合作或者有条件同步机制。 睡眠是调度发生的另一种情况，当进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;进入休眠时，它会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;把控制权交给调度器。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;有两个参数，第一个参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chan&lt;/code&gt;是休眠被唤醒的信号，这个信号使得进程可以互相通信，一个进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep(chan)&lt;/code&gt;进入休眠，另一个进程用同样的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chan&lt;/code&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup(chan)&lt;/code&gt;就可以把它唤醒。第二个参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;是调用休眠时必须持有的一个锁，这个锁主要是为了防止“遗失的唤醒”问题。一般，进程如果需要休眠，它需要循环判断某个条件是否成立（例如磁盘是否已经准备好），如果还不成立，就会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;进入休眠。例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之所以需要while循环判断，是因为如果某次事件成立了，进程从休眠中唤醒，但它被唤醒之后可能不是马上就被调度、马上就开始执行后面的代码，所以在这中间，有可能条件又不成立了，所以需要唤醒之后马上继续判断。&lt;/p&gt;

&lt;p&gt;而如果没有上面所说的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;锁，就可能发生，while判断条件不成立，进程准备进入休眠；但是这时候发生调度，另一个进程使得条件成立，想要唤醒进程，但这时候因为它还没休眠，所以找不到进程可以唤醒。再切换回原来的进程时，这个进程不知道条件已经成立了，它会进入休眠，并且之后再没有办法唤醒它。 因此，必须确保在条件判断和调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;是不会被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;打断的，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;不可以在进程真正进入sleep之前被调用。这可以用锁来实现。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Atomically release lock and sleep on chan.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Reacquires lock when awakened.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spinlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//调用sleep的进程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sleep&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sleep without lk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//必须持有lk锁&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Must acquire ptable.lock in order to&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// change p-&amp;gt;state and then call sched.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Once we hold ptable.lock, we can be&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// guaranteed that we won't miss any wakeup&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// (wakeup runs with ptable.lock locked),&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// so it's okay to release lk.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 下面sleep必须修改ptable，把这个进程的状态改为SLEEPING,并把p-&amp;gt;chan也就是休眠的等待事件改为&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第一个参数chan，因此要比较传进来的第二个参数lk是不是ptable，如果是ptable，那进程就应该一直持有它，&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//不应该释放。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//DOC: sleeplock0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//DOC: sleeplock1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;首先判断是否持有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;锁，否则报错。 然后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;需要释放&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;锁并获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable-&amp;gt;lock&lt;/code&gt;。这里有两种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;不是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable-&amp;gt;lock&lt;/code&gt;，则因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;函数也要求获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable-&amp;gt;lock&lt;/code&gt;，所以释放&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;是没问题的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable-&amp;gt;lock&lt;/code&gt;代替了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;，保证不会出现“遗失的唤醒”问题。必须在释放&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;之前，先获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;，否则有可能在释放&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;之后，获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;之前，发生调度，另一个进程此时便可以调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;。而之所以要获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable-&amp;gt;lock&lt;/code&gt;是因为之后要对进程表进行访问、修改，并且要调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;进入调度器。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable-&amp;gt;lock&lt;/code&gt;，则不需要任何操作。不可以先释放&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;然后再重新获取，原因跟上面lk释放与ptable.lock获取的顺序不能调换的原因是一样的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后进程就要进入休眠。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Go to sleep.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//休眠等待信号，wakeup函数中在ptable中查找p-&amp;gt;chan=chan并且状态为休眠的进程去唤醒。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLEEPING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//修改进程状态&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;//将控制权交给调度器&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Reacquire original lock.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//DOC: sleeplock2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;之后，该进程就被暂时挂起了，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;会将上下文切换到调度器，再从调度器切换到另外的进程。当这里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched&lt;/code&gt;返回的时候，表明进程已经被唤醒。它要将等待条件清为0，然后重新获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;锁。重新获得锁时，则不必先获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lk&lt;/code&gt;,再释放&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;，因为此时进程已经从休眠中唤醒了，它不会担心在释放和重新获得之间，其他进程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;，其他进程是否在这中间调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;对该进程是没有影响的。&lt;/p&gt;

&lt;p&gt;对应地，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakup&lt;/code&gt;函数从ptable中找到状态为SLEEPING并且在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chan&lt;/code&gt;上休眠的进程（可能多个），将它的状态设置为RUNNABLE，这样它就可以被CPU的调度器调度。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Wake up all processes sleeping on chan.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The ptable lock must be held.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;wakeup1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLEEPING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Wake up all processes sleeping on chan.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wakeup1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup1&lt;/code&gt;的加锁版本。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;因为要访问并修改ptable，所以需要持有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;作为系统调用让用户去调用时，操作系统而非用户要负责获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;锁； 但在系统中，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit&lt;/code&gt;等函数也会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup&lt;/code&gt;，但在这之前它就已经获得了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptable.lock&lt;/code&gt;锁，所以也为内核提供了不加锁的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup1&lt;/code&gt;版本。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;wait&quot;&gt;wait&lt;/h3&gt;

&lt;p&gt;wait让父进程等待子进程结束，并回收子进程的资源。它返回退出的子进程的pid，如果没有子进程或其他错误情况，则返回-1.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Wait for a child process to exit and return its pid.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Return -1 if this process has no children.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//要遍历ptable中的所有进程，找到调用进程的一个子进程&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//如果能够找到，需要修改该子进程的状态，因此要对ptable做出修改&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//不允许两个进程同时访问ptable，因此要先占有ptable的锁才能对其进行访问和修改。&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Scan through table looking for exited children.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NPROC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        		&lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//找到了该进程的子进程&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//havekids表示调用的进程有子进程&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZOMBIE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//有一个子进程调用了exit或因其他原因退出，处于ZOMBIE状态&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Found one.&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//准备返回该子进程的pid&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//释放子进程占用的内存空间，这里是释放子进程的内核栈&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将进程内核栈底指针重置为0&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;freevm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//释放页表，释放所有用户空间所占据的物理页框&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//接下来是将PCB全都重置为0&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//该PCB状态变为UNUSED，之后调用allocproc的时候，这块PCB可能就会被分配给一个新的进程&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//释放ptable锁&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//返回退出的子进程的pid&lt;/span&gt;
   	 		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ptable的遍历已经完成，到这里没有返回，说明没有子进程处于ZOMBIE&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// No point waiting if we don't have any children.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;havekids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//如果该进程并没有子进程，或者该进程在wait的过程中被杀死（比如用ctrl+C等），那就不需要等待了，直接释放ptable锁，返回-1.&lt;/span&gt;
        	&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//否则，该进程有子进程， 但所有的子进程都还在运行，必须让该进程进入休眠，等待一个子进程的结束&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Wait for children to exit. (See wakeup1 call in proc_exit.)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//调用sleep进入休眠。&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;wait()函数等待它的一个子进程终止。在exit()函数中，我们看到exit()只是关闭了进程打开的文件和从目录中退
出，但仍然保留了进程的信息，进程占据的内存和PCB都没有被释放，只是处于ZOMBIE状态。进程信息和内存
空间的释放由wait()来完成。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;遍历过一次进程表，发现有子进程，但是都还没结束，那么它就调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep(curproc, &amp;amp;ptable.lock)&lt;/code&gt;进入休眠。这个休眠会被子进程在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit&lt;/code&gt;中，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeup(myproc()-&amp;gt;parent)&lt;/code&gt;来唤醒。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Part 2 是如何在xv6中实现Round Robin调度情况统计，统计用户进程的周转、等待、执行时间。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下一篇： &lt;a href=&quot;http://localhost:4000/lab report/2020/01/31/OS4-2/&quot;&gt;Part 2&lt;/a&gt;&lt;/p&gt;</content><author><name>Shutong Chen</name></author><category term="Lab Report" /><category term="OS" /><category term="xv6" /><category term="scheduling" /><summary type="html">Lab 4：调度 调度 任何操作系统中，都可能出现进程的个数大于处理器个数的情况，这就需要考虑如何分配处理器资源。一般进程的执行是CPU计算和IO操作的循环，当进程长时间等待某种资源时，为了更好地利用CPU资源，应选择其他准备好的进程来代替它；当进程完成所需的时间过长时，为了让其他已经在系统中的进程等待时间不要过长，也需要在某个适当的时间暂停当前的进程, 因此便需要多进程并发，也就需要调度。 调度指的是决定一个进程在什么时候、是否要暂停，从一个等待队列中选择另一个进程来代替它，调度涉及调度策略的选择，也包含完成进程切换的动作。操作系统通过不断地调度，造成并发的效果，同时也为每个进程造成独占资源的假象。调度涉及以下的问题：</summary></entry><entry><title type="html">[论文笔记]基于个性化注意力机制的新闻推荐</title><link href="http://localhost:4000/paper%20reading/2020/01/30/NPA/" rel="alternate" type="text/html" title="[论文笔记]基于个性化注意力机制的新闻推荐" /><published>2020-01-30T00:00:00+08:00</published><updated>2020-01-30T00:00:00+08:00</updated><id>http://localhost:4000/paper%20reading/2020/01/30/NPA</id><content type="html" xml:base="http://localhost:4000/paper%20reading/2020/01/30/NPA/">&lt;h1 id=&quot;基于个性化注意力机制的新闻推荐&quot;&gt;基于个性化注意力机制的新闻推荐&lt;/h1&gt;

&lt;p&gt;论文链接：&lt;a href=&quot;https://arxiv.org/pdf/1907.05559.pdf&quot;&gt;https://arxiv.org/pdf/1907.05559.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇论文是2019年SIGKDD的7篇精选论文之一。主要解决的是新闻推荐中个性化的问题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;首先介绍了为什么需要新闻推荐（减少信息过载，高效获取信息）&lt;/p&gt;

&lt;p&gt;新闻推荐有什么样的难题（可以归结为如何表示新闻，以及如何表示用户兴趣）：&lt;/p&gt;

&lt;p&gt;这篇论文的作者之前已经做过一项工作，就是多视角学习的新闻推荐，所谓多视角，就是用标题、内容、类别和子类别分别去表示一篇新闻，结果是类别和子类别获得了最高的attention权重。但是在这一篇论文中，作者选择了用标题来表示新闻，原因可能是，相比内容标题更短代价更小，但是相比类别又具有更多潜在信息。&lt;/p&gt;

&lt;p&gt;但是，一个新闻标题中，并不是所有词汇都同样关键，例如That 和 Crazy的重要程度就显然不同，因此可以引入基于单词的注意力机制， 也就是给不同的单词不同的权重，来捕捉关键信息。&lt;/p&gt;

&lt;p&gt;对于第二个问题，也就是如何对用户兴趣建模，每个用户虽然点了很多篇新闻，但是，他们不是对这些新闻都同样地感兴趣，不同的新闻对用户兴趣的建模关键程度也不同。这样就可以引入一个基于新闻的注意力机制来解决。&lt;/p&gt;

&lt;p&gt;然后作者列举了已有的一些新闻推荐模型，这些模型有的也有使用attention机制来识别关键因素，但是这些attention网络都是静态的，都无法做到权重根据用户来调整。&lt;/p&gt;

&lt;p&gt;不同单词对新闻内容表示的重要程度，以及新闻对用户兴趣表示的重要程度，都是因人而异的。不同的用户看到一样的标题，他们的关注点可能不同，点击了同样的几篇文章，他们对同一篇文章的感兴趣程度也不同。因此，这两层的注意力机制还必须是个性化的，才能解决个性化推荐的问题。&lt;/p&gt;

&lt;h2 id=&quot;npa模型&quot;&gt;NPA模型&lt;/h2&gt;

&lt;p&gt;模型分为三个部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;编码新闻的news encoder&lt;/li&gt;
  &lt;li&gt;编码用户兴趣的 user encoder&lt;/li&gt;
  &lt;li&gt;预测点击新闻的概率的click predictor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;news encoder和user encoder中都使用了word-和new-两个层级的注意力网络，并且注意力网络的权重是个性化的， 相同单词、相同新闻对每个用户的权重可能不同。&lt;/p&gt;

&lt;h3 id=&quot;news-encoder&quot;&gt;News Encoder&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paper/npa1.png&quot; alt=&quot;news encoder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据新闻的标题来编码一篇新闻。分为3个子模块。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;word embedding(word2vec算法)
    &lt;ul&gt;
      &lt;li&gt;NLP中的最小单位是单词，单词组成句子，句子再组成文章。而神经网络只能接受数值性输入，因此要将自然语言的单词转换成数值向量，就是word embedding的过程。&lt;/li&gt;
      &lt;li&gt;skip-gram方法：
        &lt;ul&gt;
          &lt;li&gt;输入一个单词x，预测它的上下文y；x的表示形式用one hot encode，V是词典的大小，则输入的向量就是V维的。从x到输出f(X)是一个有一个隐层的神经网络，但是隐层是线性的，没有激活函数！ 输出也是V维的，输出是x的上下文是这V个单词的概率。&lt;/li&gt;
          &lt;li&gt;在训练完成之后，得到神经网络的权重（输入到隐层，隐层到输出层）分别是输入向量和输出向量，输入向量的维度则和隐藏层节点个数相同，因为x只有一个节点是1，其他都是0，所以输入到隐层节点的权重不会每一个都一样（否则输出就会一样），所以可以用输入向量（或者输出向量）唯一表示一个单词。这样相当于将V维的输入降维。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;论文里说用一个V*D维的word embedding矩阵来做word embedding，D的维数为300, 这里用的是已经预训练好的GloVe矩阵&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26306795&quot;&gt;[NLP] 秒懂词向量Word2vec的本质&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;CNN： 用来观察标题中的每一个局部，发掘出局部中隐藏的信息。这个卷积层的意义是，让每一个词的表示向量不仅包含这个单词本身的信息，还要包含窗口为2k+1的上下文信息。
    &lt;ul&gt;
      &lt;li&gt;这个卷积就只是一层\( N_{f} \)个卷积核，加偏置B（B的维度就是Nf维），然后用Relu激活）。&lt;/li&gt;
      &lt;li&gt;window size = 2k+1，\( \mathbf{e} \)是word embeddings连接起来得到的矩阵。输出是\( c_{1} \cdot \cdot \cdot c_{m} \)，是包含了上下文信息的词表示向量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Word Level Attention Network： 这是这个模型的重要特点之一，这里体现了个性化的注意力机制。因为每个用户在标题中对每个单词的关注度是不同的，所以attention 网络就不能像传统的注意力网络一样，对每一个用户有相同的query vector。这里使用的方法是：
    &lt;ul&gt;
      &lt;li&gt;先将用户的ID进行embedding变成一个De维的向量\( e_{u} \)（ &lt;u&gt;这里的问题，user ID不是单词是各种符号的集合如何embedding? &lt;/u&gt; )&lt;/li&gt;
      &lt;li&gt;再将用户IDembedding向量，经过一个单层的网络映射成preference query vector。这个网络有一个Relu激活： （fig3中的红色向量）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{q}_{w}=\operatorname{ReLU}\left(\mathbf{V}_{w} \times \mathbf{e}_{u}+\mathbf{v}_{w}\right)&lt;/script&gt;

    &lt;ul&gt;
      &lt;li&gt;每一个词表示向量的权重计算是：综合了词表示向量和query vector。 （fig3中的橙色向量就是权重向量α）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;a_{i}=\mathbf{c}_{i}^{T} \tanh \left(\mathbf{W}_{p} \times \mathbf{q}_{w}+\mathbf{b}_{p}\right)&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha_{i}=\frac{\exp \left(a_{i}\right)}{\sum_{j=1}^{M} \exp \left(a_{j}\right)}&lt;/script&gt;

    &lt;ul&gt;
      &lt;li&gt;最终，新闻表示就是所有词表示的加权和：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{r}_{i}=\sum_{j=1}^{M} \alpha_{j} \mathbf{c}_{j}&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;user-encoder&quot;&gt;User Encoder&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paper/npa2.png&quot; alt=&quot;user encoder&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;user encoder是对于一个用户，将所有他点击过的新闻（用该用户的ID embedding进行word attention 之后得到的新闻表示）作为输入，经过一个news level attention 网络，得到该用户的表示。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;个性化attention网络的思路跟前面差不多，还是利用了user ID embedding，生成另一个query vector：&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{q}_{d}=\operatorname{ReLU}\left(\mathbf{V}_{d} \times \mathbf{e}_{u}+\mathbf{v}_{d}\right)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;query vector qd 和 ID embedding 内积得到新闻表示的权重向量，用同样的方法：&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
a_{i}^{\prime}=&amp; \mathbf{r}_{i}^{T} \tanh \left(\mathbf{W}_{d} \times \mathbf{q}_{d}+b_{d}\right) \\
&amp; \alpha_{i}^{\prime}=\frac{\exp \left(a_{i}^{\prime}\right)}{\sum_{j=1}^{N} \exp \left(a_{i}^{\prime}\right)}
\end{aligned} %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;最终，用户的表示向量 \( \mathbf{u} \) 是该用户点击过的新闻表示向量加权和。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;click-predictor&quot;&gt;Click Predictor&lt;/h3&gt;

&lt;p&gt;在新闻推荐中，因为用户会在看到的大量新闻中，只点击其中非常少数的新闻，所以在这个问题中，正负样本是非常不平衡的，如果直接在所有candidate新闻样本上预测，训练效果显然不好，并且训练过程要花费很多时间。&lt;/p&gt;

&lt;p&gt;因此，提出一种正负样本平衡的训练方法，即联合预测K+1个样本，其中有K个负样本，1个正样本，预测每一个样本的click score：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{y}_{i}^{\prime}=\mathbf{r}_{i}^{\prime} T_{\mathbf{U}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{y}_{i}=\frac{\exp \left(\hat{y}_{i}^{\prime}\right)}{\sum_{j=0}^{K} \exp \left(\hat{y}_{j}^{\prime}\right)}&lt;/script&gt;

&lt;p&gt;预测值yi用 新闻的表示和用户表示向量的内积得到，得到的yi值 要在K+1个样本中softmax归一化。&lt;/p&gt;

&lt;p&gt;这样，整个predictor就可以看成是一个伪二分类问题，可以使用交叉熵loss函数来训练，loss function是：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{L}=-\sum_{y_{j} \in \mathcal{S}} \log \left(\hat{y}_{j}\right)&lt;/script&gt;

&lt;p&gt;只考虑正样本的损失值&lt;/p&gt;

&lt;p&gt;这样，模型从predictor到最底层的attention、CNN的参数，都是可以用back propogation来调节的。这里使用Adam来优化。&lt;/p&gt;

&lt;h2 id=&quot;实验&quot;&gt;实验&lt;/h2&gt;

&lt;h3 id=&quot;数据集&quot;&gt;数据集&lt;/h3&gt;

&lt;p&gt;数据在MSN新闻上采集，具体情况看table1，正负样本的比例是13. 这一小节还具体列举了模型一些超参数的设置。 测试集采用最近一个星期的数据，另外随机采样了10%的数据作为验证&lt;/p&gt;

&lt;p&gt;其中，user embedding（用user ID得到的）维度是De=50， 两个查询向量 的维度Dq和Dd的维度都是200.&lt;/p&gt;

&lt;h3 id=&quot;metrics&quot;&gt;metrics：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;AUC： AUC的涵义是ROC曲线下的面积。 TPrate是指，真值为1 的数据被模型预测为真的频率， FPrate是指，真值为0的数据被模型预测为真的频率。 ROC曲线的纵轴是TPrate，横轴是FPrate。 如果曲线是y=x，那么说明无论真值是0还是1，模型都以一样的概率预测为真或假，说明模型毫无辨别能力。 AUC则是ROC曲线下的面积，一般来说要在一定的FPrate下，TPrate越高越好，那么面积就要越大越好，最坏的情况就是0.5.  AUC的好处是同时考虑了模型对正例和负例的预测能力，可以规避正负样本很不平衡时带来的问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/39840928&quot;&gt;如何理解机器学习和统计中的AUC？&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MRR： 用来评价搜索算法的一种指标，如果第n个结果匹配，得分为 1/n ， 最后得分为总和。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DCGp： 是用来评价搜索算法排序好坏的一种指标，要人为地将结果分为几个等级，每个等级对应一个分数，然后分数根据排序位置衰减，最终DCG分数是p个结果得分的总和（论文里面有预测5个的也有预测10个的分数，10个分数肯定是更高的）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nDCG： 是相对DCG，是先将人工排好序的结果作为理想状态，计算此状态下的IDCG，然后用预测得到的结果除以IDCG,得到相对的nDCG。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实验结果&quot;&gt;实验结果&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;有使用神经网络的模型比使用矩阵分解的传统算法效果好&lt;/li&gt;
  &lt;li&gt;使用了negative mining的算法比不使用的算法效果更好&lt;/li&gt;
  &lt;li&gt;使用attention 机制的算法也普遍比没有使用的要好，因为新闻中的不同词以及不同新闻对于新闻本身以及用户兴趣的表现重要程度确实不同。&lt;/li&gt;
  &lt;li&gt;NPA算法在被比较的算法中表现最好。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Shutong Chen</name></author><category term="Paper Reading" /><category term="recommend system" /><category term="attention" /><summary type="html">基于个性化注意力机制的新闻推荐 论文链接：https://arxiv.org/pdf/1907.05559.pdf 这篇论文是2019年SIGKDD的7篇精选论文之一。主要解决的是新闻推荐中个性化的问题。</summary></entry></feed>